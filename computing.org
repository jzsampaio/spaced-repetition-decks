# -*- mode: org; coding: utf-8 -*-
#+STARTUP: showall
#+PROPERTY: DRILL_CARD_TYPE_ALL hide1close twosided multisided show1cloze hide2cloze show2cloze hide1_firstmore show1_firstless show1_lastmore
#+OPTIONS: prop:("drill_card_type")
#+TODO: TODO WIP | DONE

* [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::0:1][Designing Data Intensive Applications (Martin Kleppmann)]]
** Ch 2 - Query Languages
*** Item                                                            :drill:
SCHEDULED: <2022-08-02 ter>
:PROPERTIES:
:ID:       f34e796e-29b0-4d49-8d7f-4ae623801c63
:DRILL_LAST_INTERVAL: 14.4379
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:10]
:END:

2 models for structuring and querying data in a graph are:

- pr[operty] graph model
- triple-st[ore] model

three declarative qu[ery] la[nguages] for graphs: Cypher, SPARQL, and
Datalog

*** Item                                                            :drill:
SCHEDULED: <2022-07-31 dom>
:PROPERTIES:
:ID:       d8392029-d6b6-4cec-a3ba-08ee0d6a8e68
:DRILL_LAST_INTERVAL: 12.141
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:06]
:END:

Example 2-2. Representing a pr[operty] gr[aph] using a relational
schema.

#+begin_src sql
CREATE TABLE vertices (
    vertex_id   integer PRIMARY KEY,
    properties  json
);

CREATE TABLE edges (
    edge_id     integer PRIMARY KEY,
    tail_vertex integer REFERENCES vertices (vertex_id),
    head_vertex integer REFERENCES vertices (vertex_id),
    label       text,
    properties  json
);

CREATE INDEX edges_tails ON edges (tail_vertex);
CREATE INDEX edges_heads ON edges (head_vertex);
#+end_src

*** Item                                                            :drill:
SCHEDULED: <2022-08-02 ter>
:PROPERTIES:
:ID:       0afef898-2b6c-41e3-a87a-73425091fa62
:DRILL_LAST_INTERVAL: 13.8528
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:10]
:END:

The following is an example of a query in a language called C[ypher]:

#+begin_src
MATCH
  (person) -[:BORN_IN]->  () -[:WITHIN*0..]-> (us:Location {name:'United States'}),
  (person) -[:LIVES_IN]-> () -[:WITHIN*0..]-> (eu:Location {name:'Europe'})
RETURN person.name
#+end_src

*** Item                                                            :drill:
SCHEDULED: <2022-07-28 qui>
:PROPERTIES:
:ID:       1281433b-d9a5-4e7b-8940-428c0bd6442d
:DRILL_LAST_INTERVAL: 9.2094
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 2.667
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:03]
:END:

if we put graph data in a relational structure, can we also query it
using SQL?

The answer is yes, but with some difficulty. In a relational database,
you usually know in advance which j[oins] you need in your query. In a
graph query, you may need to traverse a variable number of edges
before you find the vertex you’re looking for—that is, the number of
j[oins] is not fixed in advance.

This idea of variable-length traversal paths in a query can be
expressed using something called re[cursive] co[mmon] table
expressions (the WITH RECURSIVE syntax).

*** Item                                                            :drill:
SCHEDULED: <2022-08-03 qua>
:PROPERTIES:
:ID:       a73b1f2b-a48d-4ffe-a0d0-432ec5533698
:DRILL_LAST_INTERVAL: 14.5541
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:03]
:END:

The following is an example of a query in Tu[rtle],which is a language
for tr[iple]-st[ore].

#+begin_src
@prefix : <urn:example:>.
_:lucy     a :Person;   :name "Lucy";          :bornIn _:idaho.
_:idaho    a :Location; :name "Idaho";         :type "state";   :within _:usa.
_:usa      a :Location; :name "United States"; :type "country"; :within _:namerica.
_:namerica a :Location; :name "North America"; :type "continent".
#+end_src

*** Item                                                            :drill:
SCHEDULED: <2022-07-31 dom>
:PROPERTIES:
:ID:       ce4e567e-38a7-46dc-bae4-ded288111373
:DRILL_LAST_INTERVAL: 12.2739
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:04]
:END:

In a tr[iple]-st[ore], all information is stored in the form of very
simple three-part statements: (subject, predicate, object).

*** Item                                                            :drill:
SCHEDULED: <2022-08-05 sex>
:PROPERTIES:
:ID:       6af64e26-bfa3-4ded-afb3-beff5c6bc7ce
:DRILL_LAST_INTERVAL: 16.9467
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:06]
:END:

Da[talog] is a much older language than SPARQL or Cypher, having been
studied extensively by academics in the 1980s. It is used in a few
data systems: for example, it is the query language of Datomic. It is
a subset of Pr[olog]

*** Item                                                            :drill:
SCHEDULED: <2022-07-31 dom>
:PROPERTIES:
:ID:       05717ea6-12ce-4726-9cd1-d8912588b420
:DRILL_LAST_INTERVAL: 11.8653
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:11]
:END:

New nonrelational “NoSQL” datastores have diverged in two main
directions:

- Do[cument] databases target use cases where data comes in
  self-contained documents and relationships between one document and
  another are rare.

- Gr[aph] databases go in the opposite direction, targeting use
  cases where anything is potentially related to everything.

*** Item                                                            :drill:
SCHEDULED: <2022-07-31 dom>
:PROPERTIES:
:ID:       0775cfd4-e36e-487b-a119-ac2f6f52de8c
:DRILL_LAST_INTERVAL: 11.7763
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:05]
:END:

One thing that document and graph databases have in common is that
they typically don’t enforce a sc[hema] for the data they store
... However, your application most likely still assumes that data has
a certain structure; it’s just a question of whether the schema is
ex[plicit] (enforced on write) or im[plicit] (handled on read).

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       c00e90f6-4655-4884-ad2c-78f1f3fb9ebd
:DRILL_LAST_INTERVAL: 10.5863
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:05]
:END:

M[ap]Re[duce] is a programming model for processing large amounts of
data in bulk across many machines, popularized by Google

*** Item                                                            :drill:
:PROPERTIES:
:ID:       f4b21fd3-6376-443e-979e-44d5b63d7126
:END:
*** Item                                                            :drill:
:PROPERTIES:
:ID:       e0869cab-a412-4078-bee8-f645b4176dc2
:END:
*** Item                                                            :drill:
:PROPERTIES:
:ID:       d3dac0e2-0860-46a2-b685-30f73353a8a3
:END:
** [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub][Ch 3 - Storage and Retrieval]]
*** Item                                                            :drill:
SCHEDULED: <2022-07-26 ter>
:PROPERTIES:
:ID:       e42c2510-3aa8-47b4-bfb9-6cd1546cb77a
:DRILL_LAST_INTERVAL: 4.6467
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-21 qui 10:06]
:END:

For writes, it’s hard to beat the performance of simply appending to a
file, because that’s the simplest possible write operation. Any kind
of index usually [slows down||"speeds up" or "slow down"] writes,
because the index also needs to be updated every time data is written.

*** Item                                                            :drill:
SCHEDULED: <2022-07-26 ter>
:PROPERTIES:
:ID:       684b9f25-0f23-4fdd-b2cd-9bbed0de66e5
:DRILL_LAST_INTERVAL: 4.8726
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-21 qui 10:08]
:END:

However, the hash table index also has limitations:

– The hash table must fit in mem[ory], so if you have a very large
 number of keys, you’re out of luck.
– Range queries [are not|| "are" or "are not"] efficient.

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       52dbafb6-7f74-4737-bb0d-a7d5ee4df90e
:DRILL_LAST_INTERVAL: 4.3501
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:30]
:END:

SSTable is an abbreviation of So[rted] St[ring] Tables.

They are an improvement over sequential logs, in which the keys of log
segments are sorted. This allows the usage of a Sp[arse] Index in
memory.

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       761568df-a78c-48b8-b2e1-b8843be1ad1e
:DRILL_LAST_INTERVAL: 4.6057
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:38]
:END:

How to keep keys sorted in an SSTable? An in-memory balanced tree is
used, called mem[table]. After the data surpasses a given threshold of
size, the data is written to a SSTable file.

How to recover the memtable from server crash? An associated append
only lo[g] is necessary.

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       49cb17bc-2efc-45b8-a321-d2e2b47139ca
:DRILL_LAST_INTERVAL: 4.0686
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:30]
:END:

LSM-Tree stands for: Log-Stru[ctured] Mer[ge]-Tree.

The basic idea of LSM-trees is to keep a cascade of SSTables that are
mer[ged] in the background.

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       60b9f18a-8c14-45eb-8da1-fc337ab121cc
:DRILL_LAST_INTERVAL: 4.7939
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:40]
:END:

A Bloom filter is a memory-efficient data structure for approximating
the contents of a set. It can tell you if a key [does not|| "does" or "does not"]
appear in the database, and thus saves many unnecessary disk reads for [nonexistent|| "existing" or "non existing"]
keys.

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       80f2e527-f645-4691-9052-f71ec8371c48
:DRILL_LAST_INTERVAL: 4.7029
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:29]
:END:

Most databases can fit into a B-tree that is th[ree] or fo[ur] levels
deep, so you don’t need to follow many page references to find the
page you are looking for. (A four-level tree of 4 KB pages with a
branching factor of 500 can store up to 256 TB.)

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       53466fcc-5894-4a11-bfd3-f6ac994b295e
:DRILL_LAST_INTERVAL: 4.747
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:29]
:END:

In order to make the database resilient to crashes, it is common for
B-tree implementations to include an additional data structure on
disk: a wr[ite]-ah[ead] log (WAL, also known as a redo log).

**** More

This is an append-only file to which every B-tree modification must be
written before it can be applied to the pages of the tree itself. When
the database comes back up after a crash, this log is used to restore
the B-tree back to a consistent state.

*** Item                                                             :drill:
:PROPERTIES:
:ID:       5525403f-642e-494b-8d6f-8f1fce74c6f5
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       92bd8bd2-e213-40db-91bf-3e01d89083cb
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       4ed3d871-5a3a-49a9-8acc-980b8ee6aed4
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       98be3a29-bc70-4ce3-a5b2-d31a09d3903e
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       1761b507-b628-41e1-9650-6763be52027c
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       fc365b46-8247-4e9e-91e9-40a4e4cbcd95
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       500bfd0e-eb98-4cf8-8313-df5a31d902be
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       0044f80e-0cc6-4002-bfc3-3e4a9ded7d8f
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       fa8f04af-1a70-4383-bdba-f4a8c4b6c614
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       6c6bc5d4-b93d-4ee4-9dbb-77e5e21215a6
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       734ce82b-769c-4295-8758-7f672abb4eee
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       0dbb6b55-6af1-4e68-95ad-b47283fad4e8
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       10217875-61cc-4cd6-83fe-274f201829e0
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       333cc15e-c616-4c4e-8405-a748c079d77c
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       f5abec11-6fc3-4744-b448-2f41ecc66c20
:END:
*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-25 seg]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::10:30769]]
:ID:       f0ad2436-d8bd-4316-967d-bbd4abcb961a
:END:


B-trees and LSM-trees are two ways for storing data.

Which one is generally faster for writing? [B-tree].

Which one is generally faster for reading? [LSM-tree].

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-25 seg]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::10:38718]]
:ID:       d840be01-894f-41d5-9506-926399aa6a3d
:END:

In some situations, the extra hop from the index to the he[ap] file is
too much of a performance penalty for reads, so it can be desirable to
store the indexed row directly within an index. This is known as a
clus[tered] index.

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-25 seg]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::10:41738]]
:ID:       3c821e80-4e3c-4c87-b38d-a761395094af
:END:


[R|| "R" or "B"]-trees are specialized spatial indexes. They can be used, for
example, for efficiently returning bi-dimensional range queries (e.g.:
give me the restaurants in a rectangular area).

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-25 seg]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::10:45565]]
:ID:       c20b3b63-6863-47b1-9234-93989a40ed37
:END:

 But other in-memory databases aim for durability, which can be
achieved with [special||"special" or "common"] hardware (such as battery-powered RAM), by
writing a log of changes to di[sk], by writing periodic snap[shots] to
disk, or by repl[icating] the in-memory state to other machines.

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-25 seg]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::10:46995]]
:ID:       88a54acf-8ae8-4435-a0ed-4d66b5e3f039
:END:
:LOGBOOK:
- Refiled on [2022-07-25 seg 17:47]
:END:

Counterintuitively, the performance advantage of in-memory databases
is not due to the fact that they don’t need to read from disk. Even a
disk-based storage engine may never need to read from disk if you have
enough memory, because the operating system caches rece[ntly] used disk
blocks in memory anyway. Rather, they can be faster because they can
avoid the ove[rheads] of encoding in-memory data str[uctures] in a form
that can be written to disk.
* [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::0:1][Time and Relational Theory (by Hugh Darwen, C.J. Date, and Nikos Lorentzos)]]
** [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::10:1][Ch 1 - Types and Relations]]
*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       bb981d1b-cef1-42db-8da1-89f41f20d132
:DRILL_LAST_INTERVAL: 4.3425
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:37]
:END:

~Relvar~ stands for re[lation] va[riable].

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       4d640c4b-f36f-49fb-b8e9-3491b645ac59
:DRILL_LAST_INTERVAL: 4.2313
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 2.5
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 17:51]
:END:

A type is a [set of values].

*** Item                                                            :drill:
SCHEDULED: <2022-08-05 sex>
:PROPERTIES:
:ID:       ef45c0c2-c8ee-4134-9683-a78c2bdb2c81
:DRILL_LAST_INTERVAL: 11.214
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:18]
:END:

Every value is of [exactly one|| "exactly one" or "one or more"]
types.

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       6abd658f-66a3-49ee-8b69-673a4a2c534d
:DRILL_LAST_INTERVAL: 4.3737
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:35]
:END:

Types can be sc[alar] and nonsc[allar], as well as us[er] defined and
sy[stem] defined.

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       c50ddecc-6076-4557-946f-8bee24da878a
:DRILL_LAST_INTERVAL: 4.3505
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 17:51]
:END:

*Definition of tuples in relational theory*

Let T1, T2, …, Tn (n ≥ 0) be *type names*, not necessarily all
distinct. Associate with each Ti a distinct *attribute name*, Ai; each
of the n ~attribute-name : type-name~ pairs that results is an
att[ribute]. Associate with each attribute Ai an *attribute value*,
vi, of type Ti; each of the n ~attribute : value~ pairs that results
is a comp[onent]. Then the *set* - call it t - of all n components
thus defined is a *tuple value* (or just a tuple for short) over the
attributes A1, A2, …, An. The value n is the deg[ree] of t; The set H
of all n attributes is the hea[ding] of t.

*** Item                                                            :drill:
SCHEDULED: <2022-08-05 sex>
:PROPERTIES:
:ID:       2cca3d07-da5a-48f5-a548-014da155ce80
:DRILL_LAST_INTERVAL: 11.3738
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:21]
:END:

*Definition of relation*

Let H be a tuple heading, and let t1, t2, …, tm (m ≥ 0) be distinct
tuples all with heading H. Then the *combination* - call it r - of H
and the set of tuples {t1, t2, …, tm} is a rel[ation] value (or just a
rel[ation] for short) over the attributes A1, A2, …, An, where A1, A2,
…, An are all of the attributes in H. The heading of r is H; r has the
same attributes (and hence the same attribute names and types) and the
same deg[ree] as that heading does. The set of tuples {t1, t2, …, tm} is
the bo[dy] of r. The value m is the card[inality] of r.

*** Item                                                            :drill:
SCHEDULED: <2022-08-05 sex>
:PROPERTIES:
:ID:       b8a5d624-b9ac-4b6d-a1ad-54900e55cd61
:DRILL_LAST_INTERVAL: 11.1588
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:25]
:END:

The predicate corresponding to relation r is the relation pred[icate]
for r. Further, each tuple in the body of r can be regarded as
denoting a certain prop[osition].

**** More

We can say the predicate corresponding to a given relation is the
intended interpretation, or meaning, for that relation. And the
propositions corresponding to tuples appearing in that relation are
understood by convention to be ones that evaluate to TRUE.

*** Item                                                            :drill:
SCHEDULED: <2022-07-31 dom>
:PROPERTIES:
:ID:       3d8fce34-5cbb-4b42-908a-6071ee904660
:DRILL_LAST_INTERVAL: 11.557
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:09]
:END:

A type is sc[alar] if it has no user visible components and nonscalar
otherwise.

**** More

Examples of nonscalar types are: tuples and relations.

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       d26ac10e-b219-494a-b876-b883b4f241d7
:DRILL_LAST_INTERVAL: 11.451
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:04]
:END:

#+begin_src
TYPE POINT /* geometric points in two-dimensional space */

   POSSREP CARTESIAN { X RATIONAL, Y RATIONAL … }

   POSSREP POLAR { RHO RATIONAL, THETA RATIONAL … } ;
#+end_src

Both ~Polar~ and ~Cartesian~ are pos[sible] rep[resentation] for the
type ~Point~.

*** Item                                                            :drill:
SCHEDULED: <2022-08-04 qui>
:PROPERTIES:
:ID:       5722e2bf-cf83-46ce-9c17-f1d455966d85
:DRILL_LAST_INTERVAL: 10.3802
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:18]
:END:

Every type definition includes, implicitly or explicitly, a
corresponding type con[straint], which is a specification of the set
of values that make up that type

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       b838a08e-f6b7-48b3-a117-447909fa7710
:DRILL_LAST_INTERVAL: 11.3627
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:03]
:END:

Differences between a table and a relation:

- No relation ever contains any du[plicate] tuples
- There’s no t[op] to bo[ttom] ordering to the tuples of a relation
- There’s no le[ft] to ri[ght] ordering to the attributes of a tuple or
  relation
- relations never contain nu[lls]

*** Item                                                            :drill:
SCHEDULED: <2022-08-03 qua>
:PROPERTIES:
:ID:       8e1e0bce-b9b0-47c7-8d3a-67c0cfeca757
:DRILL_LAST_INTERVAL: 14.6502
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:04]
:END:

There are exactly two nullary relations, one that contains just one
tuple (necessarily with no components, and hence a nullary tuple or
0-tuple—see the bullet item immediately following), and one that’s
empty and thus contains no tuples at all.  We refer to these two
relations colloquially as TABLE_DE[E] and TABLE_DU[M].

*** Item                                                            :drill:
SCHEDULED: <2022-08-02 ter>
:PROPERTIES:
:ID:       6f495188-8296-4ac7-a993-0835c6fcf540
:DRILL_LAST_INTERVAL: 13.5328
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:09]
:END:

If relation r has heading H, then that relation r is of type RELATION
H

RELATION here is a type gen[erator]

*** Item                                                            :drill:
SCHEDULED: <2022-08-01 seg>
:PROPERTIES:
:ID:       7a41c89b-cd78-4784-b08c-607cb8774095
:DRILL_LAST_INTERVAL: 13.407
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:11]
:END:

The Cl[osed] Wo[rld] Assumption (CWA) states that If relation r has
predicate P, then the body of r contains all and only those tuples
that correspond to instantiations of P that evaluate to TRUE.

** [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::11:1][Ch 2 - Relational Algebra]]
*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       59bb2342-3f56-40b4-91b1-0d749e0c1ed6
:DRILL_LAST_INTERVAL: 5.147
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:33]
:END:

The relational model includes an open ended [set||"set" or "list"] of
generic read-only operators known collectively as the relational
al[gebra].

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       12f7b2bd-814e-467b-b773-9d5244198e56
:DRILL_LAST_INTERVAL: 5.0342
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:27]
:END:

Relations r1 and r2 are joinable if and only if attributes with the
same name are of the [same||"same" or "different"] type.

*** Item                                                            :drill:
SCHEDULED: <2022-08-08 seg>
:PROPERTIES:
:ID:       538fd73a-da1d-4d2f-ae2e-7b1b9826db00
:DRILL_LAST_INTERVAL: 13.7543
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:24]
:END:

Is it the case that group and ungroup operators are always the inverse
of one another?

[No].

**** More

that given some relation r and some grouping of r, there’s always an
inverse ungrouping that yields r again; however, the converse isn’t
necessarily so.

*** Item                                                            :drill:
SCHEDULED: <2022-08-04 qui>
:PROPERTIES:
:ID:       3d4895a5-e652-4a73-9248-5b800ca291dd
:DRILL_LAST_INTERVAL: 10.3558
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.667
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:24]
:END:

Relational completeness is a basic measure of the expressive
capability of a language. If a language is relationally complete, then
it means—speaking very loosely, please note!—that queries of arbitrary
complexity can be formulated in that language [without|| "with" or
"without"] having to resort to branching or iterative loops.

**** More

And in order to be relationally complete, it’s sufficient that the
language in question support, directly or indirectly, all of the
following operators: restriction, projection, JOIN, UNION, NOT
MATCHING, and EXTEND (first version), together with the relational
inclusion operator “⊆”

| Operator                        | Example in Relational Algebra | Example in Tutorial D                   |
| Rename                          | r RENAME {A AS B}             | SP RENAME { SNO AS SNUM , PNO AS PNUM } |
| Restrict                        | r WHERE bx                    |                                         |
| Project                         | r{A1,A2,…,An}                 |                                         |
| Union                           | r1 UNION r2                   |                                         |
| Intersect                       | r1 Intersect r2               |                                         |
| Minus                           | r1 Minus r2                   |                                         |
| Disjoint Union                  |                               |                                         |
| Included Minus                  |                               |                                         |
| Join                            |                               |                                         |
| Matching                        |                               |                                         |
| Not Matching                    |                               |                                         |
| Extend (adding new attribute)   |                               |                                         |
| Extend (changing existing one)  |                               |                                         |
| Image relation                  |                               | EXTEND S : { PNO_REL := !!SP }          |
| Group and Ungroup               |                               |                                         |
| Wrap and Unwrap                 |                               |                                         |
| With (syntactic sugar)          |                               |                                         |

** [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::12:1][Ch 3 - Relation Varibles]]
*** Item                                                            :drill:
SCHEDULED: <2022-07-26 ter>
:PROPERTIES:
:ID:       7de98f0b-5c1b-496b-9ec6-5ac4c00cf052
:DRILL_LAST_INTERVAL: 5.0261
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-21 qui 10:02]
:END:

Are "relation values" and "relation variables" the same thing?

[No.]

Certain properties commonly thought of as properties of relation
v[alues]—e.g., the property of having keys, and the property of
possibly having foreign keys, and most especially the property of
being updatable—are more correctly seen as properties of relation
v[ariables] instead.

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       ba1299e2-0202-4ea1-8841-dc5f575f6051
:DRILL_LAST_INTERVAL: 4.6489
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:31]
:END:

Are the operators INSERT, DELETE, and UPDATE part of relational
algebra?

**** More

these operators (as well as relational assignment), since they’re all
update operators, aren’t operators of the relational algebra as such
(recall from Chapter 2 that the operators of the relational algebra
are all, by definition, *read-only* operators specifically)

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       58d73db1-09e8-4769-b7e3-4f39568fbcdd
:DRILL_LAST_INTERVAL: 4.6669
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:27]
:END:

The *Assignment Principle* states that after assignment of value v to
variable V, the comparison v = V must evaluate to [TRUE|| "True" or
"False"].

*** Item                                                            :drill:
SCHEDULED: <2022-07-26 ter>
:PROPERTIES:
:ID:       ac6afb12-5054-4dba-9897-e0488bbe165f
:DRILL_LAST_INTERVAL: 4.7066
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-21 qui 10:08]
:END:

Definition: Let K be a subset of the heading of relvar R. Then K is a
key (also known as a candidate key) for R if and only if it possesses
both of the following properties:

1.  Uni[queness]: No relation that can legally be assigned to R has
   two distinct tuples with the
same value for K.

2.  Irr[educibility]: No proper subset of K has the uniqueness property.

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       ab603dbd-95b8-4809-a37e-c5b0da9a9b52
:DRILL_LAST_INTERVAL: 4.0391
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:33]
:END:

Let X and Y be subsets of the heading of relvar R. Then the
fun[ctional] dep[endency] X→Y holds in R if and only if, in every
relation that’s a possible value of R, whenever two tuples have the
same value for X, they also have the same value for Y.

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       e09fbed9-cede-4871-b752-6d8be6e06ad1
:DRILL_LAST_INTERVAL: 4.1898
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:37]
:END:

Another name for foreign key constraint is ref[erential] constraint.

The rule that no foreign key constraint must ever be violated is the
ref[erential] int[egrity] rule.

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       5cb823f1-e3f4-457a-aedb-fb6d167946db
:DRILL_LAST_INTERVAL: 4.8165
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:38]
:END:

This requirement (i.e., that constraint violations be detected
immediately) is sometimes called *The Gol[den] Rule*. Observe that
it’s a consequence of this rule that no user [ever||"sometimes" or "ever"]
sees the database in an inconsistent state.

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       110ed85e-7680-4fc3-8d98-c2b336e47932
:DRILL_LAST_INTERVAL: 4.1313
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:26]
:END:

Database constraints do apply specifically to [relvars||"relvars" or "relation"].

**** More

Why? Because, by definition, the only way they can be violated is by
means of some update operation—and, again by definition, updates apply
to variables, not values.

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       32800aeb-d5e5-4acb-ba41-30ae42fb1ce7
:DRILL_LAST_INTERVAL: 5.342
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:28]
:END:

In the double assignment assignment, constraint checking is done [at the end of the statement|| "at the end of the statement" or "in between each statement"].

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       539af08d-e7d4-407d-a224-7d66a8f08554
:DRILL_LAST_INTERVAL: 4.039
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:41]
:END:

Definition: The Principle of Interchangeability (of views and base
relvars) states that there [must be no||"can be" or "must be no"]
arbitrary and unnecessary distinctions between base relvars and views;

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       d770d7d1-4f94-4aa1-a367-6dcad7107e81
:DRILL_LAST_INTERVAL: 4.5868
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:32]
:END:

Definition: The relational model consists of five components:

1.  An open ended collection of ty[pes], including type BOOLEAN in
   particular

2.  A relation type gen[erator] and an intended interpretation for
   relations of types generated
thereby

3.  Facilities for defining relation var[iables] of such generated
   relation types

4.  A relational ass[ignment] operator for assigning relation values
   to such relation variables

5.  A relationally com[plete], but otherwise open ended, collection of generic relational
ope[rators] for deriving relation values from other relation values

** [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::15:1][Ch 4 - Time and the Database]]
*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-25 seg]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::15:1455]]
:ID:       33b473ce-7898-4292-a7e3-82dcf450237c
:END:

A temporal database can be thought of, loosely, as a database that contains historical data
instead of or in addition to cur[rent] data.

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-25 seg]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::15:6931]]
:ID:       472ae5b6-1a1f-4d75-b39a-00d5fc872c1c
:END:

*The Information Principle (of a relational database)*

The entire information content of the database at any given time is
represented in one and only one way: The database contains only
rel[vars]

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-25 seg]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::15:11251]]
:ID:       e41aed2b-9642-4822-9872-03dde0f47946
:END:

the approach to temporal databases that we advocate
involves [no changes||"changes" or "no changes"] to the classical relational model

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-25 seg]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::15:23459]]
:ID:       78ef5565-2510-4bfc-a53a-6cbafc7e2a22
:END:
:LOGBOOK:
- Refiled on [2022-07-25 seg 18:40]
:END:

Which one can be updated? *valid time* or *transaction time*?

[valid time].

**** More

valid times can be updated, but transaction times can’t.
* [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::0:1][The Art of Immutable Architecture]]
** Ch 1 - Why Immutable Architecture
*** Item                                                            :drill:
SCHEDULED: <2022-07-31 dom>
:PROPERTIES:
:ID:       eaafd759-959b-411b-b866-53cf53b07e51
:DRILL_LAST_INTERVAL: 12.2164
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:09]
:END:

Common fallacies of distributed systems:

– The network is re[liable].
– Latency is ze[ro].
– Bandwidth is in[finite].
– The network is se[cure].
– To[pology] doesn’t change.
– There is one ad[ministrator].
– Transport cost is ze[ro].
– The network is homo[geneous].

*** Item                                                            :drill:
SCHEDULED: <2022-08-02 ter>
:PROPERTIES:
:ID:       c7c6836c-88ca-4e26-9836-ae954afeaf47
:DRILL_LAST_INTERVAL: 13.7722
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:09]
:END:

As we build new data structures, we can reuse existing pieces of old
data structures. There is no need to copy those pieces, because we
have already established that they will not change. We simply create
new data elements to represent the ones that have “changed” and let
them point to the ones that haven’t.

This is a technique called str[uctural] sh[aring]. It’s a common
optimization for immutable data structures that is enabled by
immutable data structures.

*** Item                                                            :drill:
SCHEDULED: <2022-07-31 dom>
:PROPERTIES:
:ID:       f8aa8ae1-ad7b-4968-86d4-1860a39bca65
:DRILL_LAST_INTERVAL: 12.2566
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:02]
:END:

The Two Generals’ Problem (TGP), as Jim Gray named it in 19783, has
been proven to have [zero||zero,one,two, ...] solutions.

*** Item                                                            :drill:
SCHEDULED: <2022-08-02 ter>
:PROPERTIES:
:ID:       99b767cc-b170-493e-9865-2a8a6fc5b5b4
:DRILL_LAST_INTERVAL: 14.3294
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:10]
:END:

Given the impossibility of the TGP, how can distributed systems ever
work?

We can indeed find a protocol that exchanges complete status, as long
as we allow one party to 1. act in un[certainty] and 2. remove the
de[adline].

*** Item                                                            :drill:
:PROPERTIES:
:ID:       375e568a-5e13-4304-b686-2d3d67e8a8ab
:END:
*** Item                                                            :drill:
:PROPERTIES:
:ID:       f122e300-51fb-47a0-aad8-6f08551b7fdf
:END:
*** Item                                                            :drill:
:PROPERTIES:
:ID:       cc6de256-efcc-49df-a841-f502c5b6796f
:END:
*** Item                                                            :drill:
:PROPERTIES:
:ID:       e865d3ef-b20f-43b5-bb89-f9f51da3bfd9
:END:
*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       387f756a-076a-4971-ace9-106817410f4e
:DRILL_LAST_INTERVAL: 4.3157
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:37]
:END:

As you learn to model business problems based on immutability, you
will start to enjoy the advantages of a reliable audit[able] history, just
like blockchain. And as you learn to implement immutable data
structures within your mobile apps and microservices, you will benefit
from the same auton[omy] found in Git.

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       03012db5-2641-42d1-848f-b58475b143ba
:DRILL_LAST_INTERVAL: 4.5472
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:26]
:END:

A saying:

Immutability Ch[anges] Everything

** [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::5:1][Ch. 2 - Forms of Immutable Architecture]]
*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       b0cd1781-e57f-4f18-bf08-9378ea42c0b7
:DRILL_LAST_INTERVAL: 4.6488
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:38]
:END:

*Object vs record*

We will call the things that change X, and the things that do not
change Y.

**** More

- X = object
- Y = record

*** Item                                                            :drill:
SCHEDULED: <2022-07-26 ter>
:PROPERTIES:
:ID:       630a07e9-0200-4c06-bfa2-2fc6121a4823
:DRILL_LAST_INTERVAL: 4.5107
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-21 qui 09:57]
:END:

The trade-offs requiring shift to immutability have led to the
emergence of different architectural styles. Three of those styles:
Ev[ent] Sou[rcing] (ES), Asynchronous Mo[del] Vi[ew] Up[date], and
His[torical] Mod[eling].

*** Item                                                            :drill:
SCHEDULED: <2022-08-06 sáb>
:PROPERTIES:
:ID:       73a57cc2-bed6-4ba9-b876-e1e96a76c78a
:DRILL_LAST_INTERVAL: 12.0357
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:24]
:END:

An *identity* in object-oriented programming describes the property of
objects that disti[nguishes] them from other objects.

The reason for an object to have intrinsic identity is so that it can
provide consi[stent], mea[ningful] behavior as it changes over time.

*** Item                                                            :drill:
SCHEDULED: <2022-07-26 ter>
:PROPERTIES:
:ID:       6468a5bc-251c-458a-92ac-6abaab089263
:DRILL_LAST_INTERVAL: 4.9341
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-21 qui 10:07]
:END:

Our goal now is to use immutable records to model mutable objects. The
records clearly are not the objects themselves. The immutable records
are the mut[ations] of the objects.

We will treat immutable records as obs[erved] state. Objects, on the
other hand, are der[ived] state.

*** Item                                                            :drill:
SCHEDULED: <2022-08-07 dom>
:PROPERTIES:
:ID:       5e6ed3fc-a5da-430b-8f69-813a46e11323
:DRILL_LAST_INTERVAL: 12.8135
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:18]
:END:

Der[ived] state is a deterministic transformation of obs[erved] state. It
adds no information to the system.

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       ffbb7d40-0a7b-44ce-87e4-60ea4cd3734a
:DRILL_LAST_INTERVAL: 4.8583
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:28]
:END:

The fundamental idea of Event Sou[rcing] is that of ensuring every
change to the state of an application is captured in an event object,
and that these event objects are themselves stored in the seq[uence]
they were applied for the same lifetime as the application state
itself.

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       bca45729-dc10-436f-9f3f-3d4af58ab08d
:DRILL_LAST_INTERVAL: 4.0454
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:32]
:END:

I therefore consider seq[uence] a defining characteristic of event
sourcing.

*** Item                                                            :drill:
SCHEDULED: <2022-08-06 sáb>
:PROPERTIES:
:ID:       98e6eb13-1dd1-4e32-84db-50a9c6c5d34b
:DRILL_LAST_INTERVAL: 11.8041
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:20]
:END:

Practitioners will often pair event sourcing with both Command Query
Responsibility Seg[regation] (CQRS) and Domain-Driven Des[ign]
(DDD). This pairing is not a requirement for ES, nor are the
implementations all in agreement how it is achieved

*** Item                                                            :drill:
SCHEDULED: <2022-07-26 ter>
:PROPERTIES:
:ID:       897a252d-1f1c-4413-906d-cfa383245916
:DRILL_LAST_INTERVAL: 4.7235
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-21 qui 09:58]
:END:

Command Query Responsibility Segregation extends the object-oriented
principle of Command Query Separation (CQS).

A com[mand] serves to modify objects, a qu[ery] to return information
about objects

*** Item                                                            :drill:
SCHEDULED: <2022-08-05 sex>
:PROPERTIES:
:ID:       821138d9-7c6c-401b-976a-d665b2bd5d5f
:DRILL_LAST_INTERVAL: 10.523
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:22]
:END:

In CQRS , commands and queries follow separate pa[ths] and often
interact with different architectural com[ponents]. Co[mmands] are
often asynchronous, while qu[eries] are usually synchronous. In many
implementations, they operate against different data stores.

*** Item                                                            :drill:
SCHEDULED: <2022-08-07 dom>
:PROPERTIES:
:ID:       71c95800-400c-4851-8599-50d92b90fde5
:DRILL_LAST_INTERVAL: 12.6659
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:20]
:END:

When CQRS is paired with ES, commands are further distinguished from
events. Whereas a command is expressed as an im[perative] statement,
an event is a pa[st]-tense statement. The command ~SubmitOrder~ results
in the event ~OrderSubmitted~.

*** Item                                                            :drill:
SCHEDULED: <2022-08-08 seg>
:PROPERTIES:
:ID:       7f338347-cd6a-4d25-a884-e6ec2a9d7f74
:DRILL_LAST_INTERVAL: 14.4619
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:25]
:END:

DDD recognizes two kinds of objects: entities and value types. An
en[tity] is an object that has identity. As we have already seen,
object-oriented identity affords the object the ability to change over
time. In contrast, a va[lue] type has no identity and is therefore
immutable.

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       d95f44bc-0f92-486c-8710-3a4ae43403b0
:DRILL_LAST_INTERVAL: 4.2121
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:33]
:END:

For efficiency of recomputing the current state, Event sourced
applications break that history into independent *streams*, each
stream affecting only a subset of the domain model. *When ES is
combined with DDD*, that subset is the agg[regate] ro[ot].

*** Item                                                            :drill:
SCHEDULED: <2022-08-07 dom>
:PROPERTIES:
:ID:       9def188d-fe8e-4c07-959c-b922d90eca1a
:DRILL_LAST_INTERVAL: 13.2175
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:23]
:END:

Entities in DDD are organized within hierarchies called agg[regates]. An
aggregate is a parent–child relationship. At the top of this hierarchy
is the aggregate ro[ot].

*** Item                                                            :drill:
SCHEDULED: <2022-08-05 sex>
:PROPERTIES:
:ID:       e56cd436-e0d5-4526-a404-2a9358ef2ff9
:DRILL_LAST_INTERVAL: 11.4276
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:20]
:END:

Since event sourcing is based on a seq[uence] of operations, it is
sensitive to both order and duplication. It is up to the application
developer to ensure that order is preserved and duplicates are
prevented.

*** Item                                                            :drill:
SCHEDULED: <2022-07-26 ter>
:PROPERTIES:
:ID:       49f2dbd5-bf01-499b-b614-86c7271ffc6d
:DRILL_LAST_INTERVAL: 4.9918
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-21 qui 10:00]
:END:

The pattern on which Elm is based is called Model View Up[date] .

**** More

Contrast it to: MVC

*** Item                                                            :drill:
SCHEDULED: <2022-08-07 dom>
:PROPERTIES:
:ID:       63cc05f9-be0f-473b-affb-347e6c88daa8
:DRILL_LAST_INTERVAL: 13.336
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:19]
:END:

In MVC, a cont[roller] responds to changes in the model by updating
the views. It also responds to user input in the view by updating the
model. The controller coordinates data flow in [two||one, two, ...]
directions.

**** More

The 2 directions are: both in from the user and outward from the
application.

*** Item                                                            :drill:
SCHEDULED: <2022-07-26 ter>
:PROPERTIES:
:ID:       8971109e-309b-47f0-bbe9-033c8a4084b6
:DRILL_LAST_INTERVAL: 4.5747
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-21 qui 10:00]
:END:

The problem with bidirectional data flow (e.g. in MVC where 2
controllers can depend on one another) is that it is difficult to know
whether a new feature is going to produce either of 1.  cas[cading]
updates or 2. cir[cular] dependencies.

*** Item                                                            :drill:
SCHEDULED: <2022-08-06 sáb>
:PROPERTIES:
:ID:       30b9c58d-3764-4ec3-991d-ad98ff64789f
:DRILL_LAST_INTERVAL: 12.0239
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:21]
:END:

Asynchronous Model View Update is similar to elm's model-view-update,
but extended to work across machines (e.g.: client and server). It
adds a qu[eue] to the client. Plus state updates are opt[imistically]
computed on the client, plus sent to the server. The true state is the
one in the [server||client or server].

*** Item                                                            :drill:
SCHEDULED: <2022-08-06 sáb>
:PROPERTIES:
:ID:       fd192966-5857-4cae-83e7-b80b957481e4
:DRILL_LAST_INTERVAL: 12.4536
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:19]
:END:

The Asynchronous Model View Update architecture optimistically
interprets a series of actions.  User actions are validated on-device
with the expectation that most of them will succeed on the server. It
is assumed that [no other||"other" or "no other"] actions will
intervene and that the result of executing the actions on the server
will be [the same as|| "different than" or "the same as" ] on the
client. When this optimistic assumption is found to be false, the
architecture simply dis[cards] the locally computed state and takes
the server’s version.

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       c211bf41-bd88-4827-8185-b69f267b21d3
:DRILL_LAST_INTERVAL: 4.5274
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:27]
:END:

Properties of both partial and total order:

- tra[nsitive]: a<b and b<c ⇒ a<c
- non re[flexive]: a≮a
- unid[irectional]: a<b ⇒ b≮a

In a total order, for a and b distinct:

- a≮b ⇒ [b<a]

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       2c5878b0-1339-43d9-b19a-63c0ae5784cc
:DRILL_LAST_INTERVAL: 4.2744
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:34]
:END:

The way in which Historical Modeling puts facts into a partial order
is to identify pred[ecessors] .

*** Item                                                            :drill:
SCHEDULED: <2022-07-26 ter>
:PROPERTIES:
:ID:       2d518cf9-b70d-4da3-9377-0485a75a8c6a
:DRILL_LAST_INTERVAL: 4.8028
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-21 qui 10:03]
:END:

A fact does not know about its successors . New successors are added
over time. To fully understand the state of a fact, we must query the
historical model to discover if new suc[cessors] have been created.

*** Item                                                            :drill:
SCHEDULED: <2022-07-26 ter>
:PROPERTIES:
:ID:       6ad2e891-3a96-47e0-893b-cad9e82f215d
:DRILL_LAST_INTERVAL: 5.0587
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-21 qui 10:06]
:END:

Since a fact refers to its predecessors , and the fact is immutable,
it follows that a predecessor [cannot||cannot or can] be added to an
existing fact.

*** Item                                                            :drill:
SCHEDULED: <2022-08-07 dom>
:PROPERTIES:
:ID:       f2eaf78c-e740-42c4-a1c4-4181bf4897b8
:DRILL_LAST_INTERVAL: 12.5496
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.667
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:18]
:END:

The transitive clo[sure] identifies the starting fact. There is no
other fact for which the transitive clo[sure] would produce this same
set. In a historical model, this is the only way to identify a fact.

**** More

They do not have globally unique identifiers (GUIDs) or sequence
numbers outside of this structure. The contents of the facts in the
transitive closure are all you’ve got to tell one fact apart from
another.

*** Item                                                            :drill:
SCHEDULED: <2022-08-05 sex>
:PROPERTIES:
:ID:       4406e716-3800-4915-bf9f-7f2305d296f8
:DRILL_LAST_INTERVAL: 10.7701
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:22]
:END:

In *Historical Modeling*, the immutability of facts constrains them to
know their predecessors at the time of creation.  But there are two
more constraints that we have to put on the system. We must disallow
both sim[ultaneous] creation and self-ref[erence], lest we introduce
cycles.

*** Item                                                            :drill:
SCHEDULED: <2022-08-02 ter>
:PROPERTIES:
:ID:       d8e751a6-680b-4ca9-80af-386d6f9fef65
:DRILL_LAST_INTERVAL: 8.0024
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:22]
:END:

On *Historical Modeling*, for every party in the system to eventually
reach the same conclusion, that conclusion [cannot|| "must" or
"cannot"] be based on timeliness.

**** More

Only by arbitration of a central authority can these situations be
resolved.

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       add38a56-03fd-48b8-83f3-13c643bd43d7
:DRILL_LAST_INTERVAL: 4.4029
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:35]
:END:

In Historical Modeling, At best, we can speak of failure of
information to arrive at a certain place by a certain time. But we
[cannot|| "can" or "cannot"] prove that the information did not exist
somewhere else at that time. And when the fact arrives later, we must
decide how we are to react to it.

*** Item                                                            :drill:
SCHEDULED: <2022-07-26 ter>
:PROPERTIES:
:ID:       d15d0abd-a5f5-4f33-8eeb-bb6f498799f1
:DRILL_LAST_INTERVAL: 4.5268
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-21 qui 10:03]
:END:

Should one use historical modeling for a system that must reserve the
use of scarce resources?

[Probably not].

**** More

When a reservation is approved, the approver needs to know that no
other reservation for the same room at the same time has been
approved. That decision must be made by a central authority.

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       dccbda35-0cf0-41de-b08d-b2a8e0ab75ae
:DRILL_LAST_INTERVAL: 4.2749
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:27]
:END:

Is there any room for a historical model on a system that requires
central authority to define strict usage of scarce resources?

Yes, at the ed[ges] of the central authority.

**** Answer

The historical model can capture the fact that a request has been
made,as well as capture the fact that a request was approved.

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       707a6b28-0b30-408b-89e7-aa370c85dcfb
:DRILL_LAST_INTERVAL: 3.9421
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:32]
:END:

A domain that requires at most one result [cannot|| can or cannot]
effectively be modeled historically.

**** More

For example, a login that requires a unique user name should be
supported by a static model.  A historical model would be unable to
enforce the uniqueness of a user name.

*** Item                                                            :drill:
SCHEDULED: <2022-08-06 sáb>
:PROPERTIES:
:ID:       6380d48f-ad5b-4c07-8640-6856b68d9daa
:DRILL_LAST_INTERVAL: 11.9157
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:24]
:END:

Limitations of historical modeling:

- no central authority
- no real time clock
- no uniq[ueness] constraint
- no agg[regation]

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       7220fbc1-173b-44c3-a666-8b62455524c7
:DRILL_LAST_INTERVAL: 4.2785
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:35]
:END:

When designing a system that requires aggregates over history, add a
sta[tic] model—whether singular or sharded—to the historical one.

**** More

Model individual transactions historically. At a central authority,
collect a list of ongoing historical facts into the static model. At
regular intervals, close the tally of facts and compute a summary.

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       0e9eb6da-781a-4c59-9ac9-ac7ed7932af0
:DRILL_LAST_INTERVAL: 3.755
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:40]
:END:

The distinctive characteristic of Historical Modeling(HM) when
compared to Event Sourcing and MVU is that HM [does not||"does not" or "does"] assume that
historical events occurred within a fully ord[ered] sequence.

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       ea8928d7-ed42-48ad-9054-1e12bc798bd2
:DRILL_LAST_INTERVAL: 3.9835
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 18:43]
:END:

In Historical Modeling, Instead of referring to historical records as
events or actions, let us call them fa[cts].

** [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::6:1][Ch. 3 - How to Read a Historical Model]]
*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       aaf2ab8c-2159-4603-b7a2-5ce708cd3924
:DRILL_LAST_INTERVAL: 4.9252
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:29]
:END:

The *fact type diagram* expresses both the car[dinality] and the
cau[sality] of the domain. Reading through it reveals a narrative of
how a system came to be in a particular state and exposes the
constraints on how that system can and cannot change.

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       ddbf7607-e4c2-4963-b429-247d3fbd4d96
:DRILL_LAST_INTERVAL: 4.3724
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:26]
:END:

In a fact type diagram, the nodes are ty[pes] and the directed arrows
indicate pre[decessor] hierarchy.

On the diagram ~(A) -> (B)~, A is the [successor|| "sucessor" or "predecessor"],
and B is the [predecessor|| "sucessor" or "predecessor"].

Labels on the arrows are [optional|| "mandatory" or "optional"].

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       b97519c9-66a8-40ae-b981-33b483ffe8e6
:DRILL_LAST_INTERVAL: 4.1433
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:28]
:END:

On domain modeling, we can never limit the number of successors, but
we can express the number of predecessors in a few ways:

- [?] :: Zero or One
- [*] :: Zero or many
- [-] :: Exactly one

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       d72d6a30-5878-49b1-9bae-5e541d1e2dc7
:DRILL_LAST_INTERVAL: 4.0032
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:37]
:END:

Are loops allowed in a fact *type* diagram?

[Yes.]

**** More

Even though this relationship introduces a cycle into the fact type
graph, it does not allow cycles of fact instances.

A fact instance diagram does not admit cycles. A fact never refers to
itself as a predecessor.  Nor can facts refer to predecessors that in
turn refer to the original, directly or indirectly.

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       d9ae11de-2c29-49b6-af8e-5ccba9f14862
:DRILL_LAST_INTERVAL: 4.0475
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:35]
:END:

Are loops allowed in a fact *instance* diagram?

[No.]

**** More

A fact instance diagram does not admit cycles. A fact never refers to
itself as a predecessor.  Nor can facts refer to predecessors that in
turn refer to the original, directly or indirectly.

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       027b6e35-4e1f-4d21-9bb1-7ef11d58b455
:DRILL_LAST_INTERVAL: 4.6412
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:30]
:END:

Whereas fact type diagrams are general descriptions of a model, fact
instance diagrams show specific ex[amples].

**** More

They offer a form of debugging prior to a model having been implemented.

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       a017f78d-84dc-49a5-9a04-cbf1101c73f0
:DRILL_LAST_INTERVAL: 4.9942
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:40]
:END:

In Historical Modeling, a fact is uniquely identified by its ty[pe],
the va[lues] of its fi[elds], and the *set* of its pred[ecessors].

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-25 seg]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::6:23266]]
:END:


The book Immutable Architecture proposes a textual language for modeling the domains. This languange is called Fact[ual].

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-25 seg]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::6:35995]]
:END:

What are the missing keywords?

fa[ct] Win {
  game: Game
  player: Player
  moves: Move*
}

qu[ery] cartsContainingProduct(p: Product) {
  ma[tch] ol: OrderLine where ol.price.product = p
  th[en] c: Cart where c = ol.cart
}

query currentPriceOfProduct(pr: Product) {
  match p: Price where p.product = pr
    su[ch] that not exists next: Price where next.prior = p
}

aut[horize] ol: OrderLine {
  match u: User where ol.cart.createdBy = u
}
** [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::8:1][Ch. 4 - Location Independence]]
* Articles and Blog Posts
:LOGBOOK:
- Refiled on [2022-07-25 seg 19:34]
:END:
** [[https://fsharpforfunandprofit.com/posts/concurrency-actor-model/][Messages and Agents]] (F# for fun and profit)
*** Item                                                            :drill:
SCHEDULED: <2022-08-05 sex>
:PROPERTIES:
:ID:       8d3c2d3b-54fe-47bf-9377-7ca9c37ac0e9
:DRILL_LAST_INTERVAL: 17.3149
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:09]
:END:

What is the difference between message-base and actor-based (both in
the scope of approaches to concurrency)?

[None. They are the same]

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       e98cd652-0a7b-42f5-938e-7e4c74239050
:DRILL_LAST_INTERVAL: 10.3672
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:06]
:END:

On the actor-based model, each actor has its own mailbox and isolated
state. Based on its designated behavior, the actor responds to
incoming messages by se[nd] new messages, sp[awn] new actors and/or
changing its internal st[ate].

*** Item                                                            :drill:
SCHEDULED: <2022-08-02 ter>
:PROPERTIES:
:ID:       138c586c-4397-4e88-a89e-bbc70a1c750b
:DRILL_LAST_INTERVAL: 13.6423
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:10]
:END:

In the actor-based modeling, messages are sent as[ynchronously] and
can take arbitrarily long to eventually arrive in the mailbox of the
receiver. Also, the actor models makes no guarantees on the or[dering]
of messages

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       490dc4e4-1734-4a11-a3b0-99b795eba4ba
:DRILL_LAST_INTERVAL: 10.8807
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:05]
:END:

Despite being lock free, can concurrency issues still happen on a
system developed w/ the actor model?

[Yes. concurrency issues like deadlocks and race conditions are still
not entirely expelled in this programming model, as they can be
reintroduced by incorrect applications.]

*** Item                                                            :drill:
SCHEDULED: <2022-07-31 dom>
:PROPERTIES:
:ID:       f381e7e5-600d-4ae8-bda3-595837b59a7b
:DRILL_LAST_INTERVAL: 12.2989
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:10]
:END:

When building a web app with the actor model, Often, the flow of a
single request represents a more or less complex message flow between
multiple actors, using messaging pa[tterns] such as scatter/gather,
router, enricher or aggregator

** [[https://mattferderer.com/what-is-the-actor-model-and-when-should-you-use-it/][What is the Actor Model & When Should You Use it?]]

*** Item                                                            :drill:
SCHEDULED: <2022-08-02 ter>
:PROPERTIES:
:ID:       5652d00e-9f90-4d36-8aa6-01e9ebb4632d
:DRILL_LAST_INTERVAL: 13.6826
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:02]
:END:

2 programming languages built around the concept of message passing:
sm[alltalk] and ea[rlang].

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       dda55805-c5cf-4f9b-8c42-fed64a816853
:DRILL_LAST_INTERVAL: 11.2535
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:02]
:END:

Example of when not to use the actor model:

- when you need a seq[uential] order of things to happen.

*** Item                                                            :drill:
SCHEDULED: <2022-07-31 dom>
:PROPERTIES:
:ID:       7cd7ce70-c4f9-4089-b4b6-49de61d22db3
:DRILL_LAST_INTERVAL: 12.0725
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:05]
:END:

Orleans is a powerful tool to implement ac[tor] model pattern and it
is very useful in order developing APIs using Actor model in ASP.NET
Core.

** [[http://v2matveev.blogspot.com/2010/04/mailboxprocessors-erlang-style.html][MailboxProcessors: Erlang-style concurrency in F#]]

*** Item                                                            :drill:
SCHEDULED: <2022-07-31 dom>
:PROPERTIES:
:ID:       9019a660-7cd0-478a-939a-22df190bc074
:DRILL_LAST_INTERVAL: 11.8731
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:02]
:END:

F#'s mailbox processor allows for searching messages of particular
type. This can be done w/ the functions ~S[can]~ and ~T[ryScan]~.

*** Item                                                            :drill:
:PROPERTIES:
:ID:       9c9f81c1-ca87-44ad-9eb2-3d3d15578d98
:END:
*** Item                                                            :drill:
:PROPERTIES:
:ID:       6011fac2-f2fb-46e9-92d8-f60177dbb776
:END:
*** Item                                                            :drill:
:PROPERTIES:
:ID:       a305c94c-d415-4a09-a56a-045830d0188b
:END:
