# -*- mode: org; coding: utf-8 -*-
#+STARTUP: showall
#+PROPERTY: DRILL_CARD_TYPE_ALL hide1close twosided multisided show1cloze hide2cloze show2cloze hide1_firstmore show1_firstless show1_lastmore
#+OPTIONS: prop:("drill_card_type")
#+TODO: TODO WIP | DONE

* [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::0:1][Designing Data Intensive Applications (Martin Kleppmann)]]
** Ch 2 - Query Languages
*** Item                                                            :drill:
SCHEDULED: <2022-09-09 sex>
:PROPERTIES:
:ID:       f34e796e-29b0-4d49-8d7f-4ae623801c63
:DRILL_LAST_INTERVAL: 38.0758
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-08-02 ter 13:20]
:END:

2 models for structuring and querying data in a graph are:

- pr[operty] graph model
- triple-st[ore] model

three declarative qu[ery] la[nguages] for graphs: Cypher, SPARQL, and
Datalog

*** Item                                                            :drill:
SCHEDULED: <2022-09-05 seg>
:PROPERTIES:
:ID:       d8392029-d6b6-4cec-a3ba-08ee0d6a8e68
:DRILL_LAST_INTERVAL: 34.1004
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-08-02 ter 13:13]
:END:

Example 2-2. Representing a pr[operty] gr[aph] using a relational
schema.

#+begin_src sql
CREATE TABLE vertices (
    vertex_id   integer PRIMARY KEY,
    properties  json
);

CREATE TABLE edges (
    edge_id     integer PRIMARY KEY,
    tail_vertex integer REFERENCES vertices (vertex_id),
    head_vertex integer REFERENCES vertices (vertex_id),
    label       text,
    properties  json
);

CREATE INDEX edges_tails ON edges (tail_vertex);
CREATE INDEX edges_heads ON edges (head_vertex);
#+end_src

*** Item                                                            :drill:
SCHEDULED: <2022-09-08 qui>
:PROPERTIES:
:ID:       0afef898-2b6c-41e3-a87a-73425091fa62
:DRILL_LAST_INTERVAL: 37.0076
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-08-02 ter 13:20]
:END:

The following is an example of a query in a language called C[ypher]:

#+begin_src
MATCH
  (person) -[:BORN_IN]->  () -[:WITHIN*0..]-> (us:Location {name:'United States'}),
  (person) -[:LIVES_IN]-> () -[:WITHIN*0..]-> (eu:Location {name:'Europe'})
RETURN person.name
#+end_src

*** Item                                                            :drill:
SCHEDULED: <2022-08-22 seg>
:PROPERTIES:
:ID:       1281433b-d9a5-4e7b-8940-428c0bd6442d
:DRILL_LAST_INTERVAL: 24.4487
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.25
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 16:24]
:END:

if we put graph data in a relational structure, can we also query it
using SQL?

The answer is yes, but with some difficulty. In a relational database,
you usually know in advance which j[oins] you need in your query. In a
graph query, you may need to traverse a variable number of edges
before you find the vertex you’re looking for—that is, the number of
j[oins] is not fixed in advance.

This idea of variable-length traversal paths in a query can be
expressed using something called re[cursive] co[mmon] table
expressions (the WITH RECURSIVE syntax).

*** Item                                                            :drill:
SCHEDULED: <2022-08-03 qua>
:PROPERTIES:
:ID:       a73b1f2b-a48d-4ffe-a0d0-432ec5533698
:DRILL_LAST_INTERVAL: 14.5541
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:03]
:END:

The following is an example of a query in Tu[rtle],which is a language
for tr[iple]-st[ore].

#+begin_src
@prefix : <urn:example:>.
_:lucy     a :Person;   :name "Lucy";          :bornIn _:idaho.
_:idaho    a :Location; :name "Idaho";         :type "state";   :within _:usa.
_:usa      a :Location; :name "United States"; :type "country"; :within _:namerica.
_:namerica a :Location; :name "North America"; :type "continent".
#+end_src

*** Item                                                            :drill:
SCHEDULED: <2022-09-06 ter>
:PROPERTIES:
:ID:       ce4e567e-38a7-46dc-bae4-ded288111373
:DRILL_LAST_INTERVAL: 34.8662
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-08-02 ter 13:13]
:END:

In a tr[iple]-st[ore], all information is stored in the form of very
simple three-part statements: (subject, predicate, object).

*** Item                                                            :drill:
SCHEDULED: <2022-08-05 sex>
:PROPERTIES:
:ID:       6af64e26-bfa3-4ded-afb3-beff5c6bc7ce
:DRILL_LAST_INTERVAL: 16.9467
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:06]
:END:

Da[talog] is a much older language than SPARQL or Cypher, having been
studied extensively by academics in the 1980s. It is used in a few
data systems: for example, it is the query language of Datomic. It is
a subset of Pr[olog]

*** Item                                                            :drill:
SCHEDULED: <2022-09-05 seg>
:PROPERTIES:
:ID:       05717ea6-12ce-4726-9cd1-d8912588b420
:DRILL_LAST_INTERVAL: 33.9017
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-08-02 ter 13:14]
:END:

New nonrelational “NoSQL” datastores have diverged in two main
directions:

- Do[cument] databases target use cases where data comes in
  self-contained documents and relationships between one document and
  another are rare.

- Gr[aph] databases go in the opposite direction, targeting use
  cases where anything is potentially related to everything.

*** Item                                                            :drill:
SCHEDULED: <2022-09-07 qua>
:PROPERTIES:
:ID:       0775cfd4-e36e-487b-a119-ac2f6f52de8c
:DRILL_LAST_INTERVAL: 36.0228
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-08-02 ter 13:14]
:END:

One thing that document and graph databases have in common is that
they typically don’t enforce a sc[hema] for the data they store
... However, your application most likely still assumes that data has
a certain structure; it’s just a question of whether the schema is
ex[plicit] (enforced on write) or im[plicit] (handled on read).

*** Item                                                            :drill:
SCHEDULED: <2022-09-05 seg>
:PROPERTIES:
:ID:       c00e90f6-4655-4884-ad2c-78f1f3fb9ebd
:DRILL_LAST_INTERVAL: 33.5879
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-08-02 ter 13:11]
:END:

M[ap]Re[duce] is a programming model for processing large amounts of
data in bulk across many machines, popularized by Google

*** Item                                                            :drill:
:PROPERTIES:
:ID:       f4b21fd3-6376-443e-979e-44d5b63d7126
:END:
*** Item                                                            :drill:
:PROPERTIES:
:ID:       e0869cab-a412-4078-bee8-f645b4176dc2
:END:
*** Item                                                            :drill:
:PROPERTIES:
:ID:       d3dac0e2-0860-46a2-b685-30f73353a8a3
:END:
** [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub][Ch 3 - Storage and Retrieval]]
*** Item                                                            :drill:
SCHEDULED: <2022-08-08 seg>
:PROPERTIES:
:ID:       e42c2510-3aa8-47b4-bfb9-6cd1546cb77a
:DRILL_LAST_INTERVAL: 12.4723
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-27 qua 12:56]
:END:

For writes, it’s hard to beat the performance of simply appending to a
file, because that’s the simplest possible write operation. Any kind
of index usually [slows down||"speeds up" or "slow down"] writes,
because the index also needs to be updated every time data is written.

*** Item                                                            :drill:
SCHEDULED: <2022-08-09 ter>
:PROPERTIES:
:ID:       684b9f25-0f23-4fdd-b2cd-9bbed0de66e5
:DRILL_LAST_INTERVAL: 13.0365
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-27 qua 12:54]
:END:

However, the hash table index also has limitations:

– The hash table must fit in mem[ory], so if you have a very large
 number of keys, you’re out of luck.
– Range queries [are not|| "are" or "are not"] efficient.

*** Item                                                            :drill:
SCHEDULED: <2022-08-12 sex>
:PROPERTIES:
:ID:       52dbafb6-7f74-4737-bb0d-a7d5ee4df90e
:DRILL_LAST_INTERVAL: 14.4848
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 16:23]
:END:

SSTable is an abbreviation of So[rted] St[ring] Tables.

They are an improvement over sequential logs, in which the keys of log
segments are sorted. This allows the usage of a Sp[arse] Index in
memory.

*** Item                                                            :drill:
SCHEDULED: <2022-08-15 seg>
:PROPERTIES:
:ID:       761568df-a78c-48b8-b2e1-b8843be1ad1e
:DRILL_LAST_INTERVAL: 13.4486
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-08-02 ter 13:12]
:END:

How to keep keys sorted in an SSTable? An in-memory balanced tree is
used, called mem[table]. After the data surpasses a given threshold of
size, the data is written to a SSTable file.

How to recover the memtable from server crash? An associated append
only lo[g] is necessary.

*** Item                                                            :drill:
SCHEDULED: <2022-08-10 qua>
:PROPERTIES:
:ID:       49cb17bc-2efc-45b8-a321-d2e2b47139ca
:DRILL_LAST_INTERVAL: 11.7063
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 16:23]
:END:

LSM-Tree stands for: Log-Stru[ctured] Mer[ge]-Tree.

The basic idea of LSM-trees is to keep a cascade of SSTables that are
mer[ged] in the background.

*** Item                                                            :drill:
SCHEDULED: <2022-08-15 seg>
:PROPERTIES:
:ID:       60b9f18a-8c14-45eb-8da1-fc337ab121cc
:DRILL_LAST_INTERVAL: 12.5939
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-08-02 ter 13:12]
:END:

A Bloom filter is a memory-efficient data structure for approximating
the contents of a set. It can tell you if a key [does not|| "does" or "does not"]
appear in the database, and thus saves many unnecessary disk reads for [nonexistent|| "existing" or "non existing"]
keys.

*** Item                                                            :drill:
SCHEDULED: <2022-08-15 seg>
:PROPERTIES:
:ID:       80f2e527-f645-4691-9052-f71ec8371c48
:DRILL_LAST_INTERVAL: 13.3987
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-08-02 ter 13:12]
:END:

Most databases can fit into a B-tree that is th[ree] or fo[ur] levels
deep, so you don’t need to follow many page references to find the
page you are looking for. (A four-level tree of 4 KB pages with a
branching factor of 500 can store up to 256 TB.)

*** Item                                                            :drill:
SCHEDULED: <2022-08-16 ter>
:PROPERTIES:
:ID:       53466fcc-5894-4a11-bfd3-f6ac994b295e
:DRILL_LAST_INTERVAL: 13.6031
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-08-02 ter 13:12]
:END:

In order to make the database resilient to crashes, it is common for
B-tree implementations to include an additional data structure on
disk: a wr[ite]-ah[ead] log (WAL, also known as a redo log).

**** More

This is an append-only file to which every B-tree modification must be
written before it can be applied to the pages of the tree itself. When
the database comes back up after a crash, this log is used to restore
the B-tree back to a consistent state.

*** Item                                                             :drill:
:PROPERTIES:
:ID:       5525403f-642e-494b-8d6f-8f1fce74c6f5
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       92bd8bd2-e213-40db-91bf-3e01d89083cb
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       4ed3d871-5a3a-49a9-8acc-980b8ee6aed4
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       98be3a29-bc70-4ce3-a5b2-d31a09d3903e
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       1761b507-b628-41e1-9650-6763be52027c
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       fc365b46-8247-4e9e-91e9-40a4e4cbcd95
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       500bfd0e-eb98-4cf8-8313-df5a31d902be
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       0044f80e-0cc6-4002-bfc3-3e4a9ded7d8f
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       fa8f04af-1a70-4383-bdba-f4a8c4b6c614
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       6c6bc5d4-b93d-4ee4-9dbb-77e5e21215a6
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       734ce82b-769c-4295-8758-7f672abb4eee
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       0dbb6b55-6af1-4e68-95ad-b47283fad4e8
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       10217875-61cc-4cd6-83fe-274f201829e0
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       333cc15e-c616-4c4e-8405-a748c079d77c
:END:
*** Item                                                             :drill:
:PROPERTIES:
:ID:       f5abec11-6fc3-4744-b448-2f41ecc66c20
:END:
*** Item                                                            :drill:
SCHEDULED: <2022-08-16 ter>
:PROPERTIES:
:DATE_ADDED: [2022-07-25 seg]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::10:30769]]
:ID:       f0ad2436-d8bd-4316-967d-bbd4abcb961a
:DRILL_LAST_INTERVAL: 14.0944
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.667
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-08-02 ter 13:19]
:END:

B-trees and LSM-trees are two ways for storing data.

Which one is generally faster for writing? [LSM-tree].

Which one is generally faster for reading? [B-tree].

*** Item                                                            :drill:
SCHEDULED: <2022-08-14 dom>
:PROPERTIES:
:DATE_ADDED: [2022-07-25 seg]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::10:38718]]
:ID:       d840be01-894f-41d5-9506-926399aa6a3d
:DRILL_LAST_INTERVAL: 12.4846
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-08-02 ter 13:19]
:END:

In some situations, the extra hop from the index to the he[ap] file is
too much of a performance penalty for reads, so it can be desirable to
store the indexed row directly within an index. This is known as a
clus[tered] index.

*** Item                                                            :drill:
SCHEDULED: <2022-08-16 ter>
:PROPERTIES:
:DATE_ADDED: [2022-07-25 seg]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::10:41738]]
:ID:       3c821e80-4e3c-4c87-b38d-a761395094af
:DRILL_LAST_INTERVAL: 14.3063
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-08-02 ter 13:20]
:END:


[R|| "R" or "B"]-trees are specialized spatial indexes. They can be used, for
example, for efficiently returning bi-dimensional range queries (e.g.:
give me the restaurants in a rectangular area).

*** Item                                                            :drill:
SCHEDULED: <2022-08-14 dom>
:PROPERTIES:
:DATE_ADDED: [2022-07-25 seg]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::10:45565]]
:ID:       c20b3b63-6863-47b1-9234-93989a40ed37
:DRILL_LAST_INTERVAL: 11.5455
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-08-02 ter 13:13]
:END:

 But other in-memory databases aim for durability, which can be
achieved with [special||"special" or "common"] hardware (such as battery-powered RAM), by
writing a log of changes to di[sk], by writing periodic snap[shots] to
disk, or by repl[icating] the in-memory state to other machines.

*** Item                                                            :drill:
SCHEDULED: <2022-08-15 seg>
:PROPERTIES:
:DATE_ADDED: [2022-07-25 seg]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::10:46995]]
:ID:       88a54acf-8ae8-4435-a0ed-4d66b5e3f039
:DRILL_LAST_INTERVAL: 12.7444
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-08-02 ter 13:19]
:END:
:LOGBOOK:
- Refiled on [2022-07-25 seg 17:47]
:END:

Counterintuitively, the performance advantage of in-memory databases
is not due to the fact that they don’t need to read from disk. Even a
disk-based storage engine may never need to read from disk if you have
enough memory, because the operating system caches rece[ntly] used disk
blocks in memory anyway. Rather, they can be faster because they can
avoid the ove[rheads] of encoding in-memory data str[uctures] in a form
that can be written to disk.
*** Item                                                            :drill:
SCHEDULED: <2022-08-03 qua>
:PROPERTIES:
:DATE_ADDED: [2022-07-27 qua]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::10:50964]]
:ID:       13cefb5d-ec1d-47cb-a59d-8e9601e9c087
:DRILL_LAST_INTERVAL: 5.0201
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 16:24]
:END:

- OLTP :: online tran[saction] processing
- OLAP :: online anal[ytic] processing

*** Item                                                            :drill:
SCHEDULED: <2022-08-03 qua>
:PROPERTIES:
:DATE_ADDED: [2022-07-27 qua]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::10:53516]]
:ID:       629bc924-f725-426c-ac6f-6f08ce13de14
:DRILL_LAST_INTERVAL: 4.5549
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 16:25]
:END:


A data war[ehouse] is a separate database that analysts can query to
their hearts’ content, without affecting OLTP operations. The data
warehouse contains a read-only copy of the data in all the various
OLTP systems in the company. Data is extracted from OLTP databases,
transformed into an analysis-friendly schema, cleaned up, and then
loaded into the data war[ehouse]. This process of getting data into
the warehouse is known as Extract–Transform–Load [ETL] and is
illustrated in Figure 3-8.

*** Item                                                            :drill:
SCHEDULED: <2022-08-03 qua>
:PROPERTIES:
:DATE_ADDED: [2022-07-27 qua]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::10:59272]]
:ID:       e965c624-26cc-4567-b6e5-f307cb15b34e
:DRILL_LAST_INTERVAL: 4.737
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 16:24]
:END:

star vs snowflake schema

The name “[star] schema” comes from the fact that when the table
relationships are visualized, the fact table is in the middle,
surrounded by its dimension tables; the connections to these tables
are like the rays of a star.

A variation of this template is known as the [snowflake] schema, where
dimensions are further broken down into subdimensions.

[Snowflake] schemas are more normalized than [star] schemas, but [star]
schemas are often preferred because they are simpler for analysts to
work with.

*** Item                                                            :drill:
SCHEDULED: <2022-08-12 sex>
:PROPERTIES:
:DATE_ADDED: [2022-07-27 qua]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::10:72811]]
:ID:       255e3f77-d0b6-4473-b863-92af3497f168
:DRILL_LAST_INTERVAL: 10.2285
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-08-02 ter 13:20]
:END:
:LOGBOOK:
- Refiled on [2022-07-27 qua 13:16]
:END:

One way of creating a cache of pre-computed results in an rdbms is a
mat[erialized] view. In a relational data model, it is often defined
like a standard (virtual) view: a table-like object whose contents are
the results of some query. The difference is that a mat[erialized] view
is an actual copy of the query results, written to disk, whereas a
virtual view is just a shortcut for writing queries.
** [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::11:1][Ch 4 - Encoding and Evolution of Schemas]]
*** Item                                                            :drill:
SCHEDULED: <2022-08-06 sáb>
:PROPERTIES:
:DATE_ADDED: [2022-07-29 sex]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::11:13544]]
:ID:       6ff66c71-1c97-4bf2-adb8-ed7a63a1dce6
:DRILL_LAST_INTERVAL: 4.091
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-08-02 ter 13:21]
:END:

Apache *Thrift*, Apache *Avro*, and Protocol Buffers (*protobuf*) are
binary encoding libraries. You can use them to represent your
data. They can be seen as alternatives to j[son] and x[ml].

*** Item                                                            :drill:
SCHEDULED: <2022-08-06 sáb>
:PROPERTIES:
:DATE_ADDED: [2022-07-29 sex]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::11:29075]]
:ID:       79fec43d-e9f1-4e82-babc-e238747807dd
:DRILL_LAST_INTERVAL: 4.0813
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-08-02 ter 13:20]
:END:

When compared to json and xml, Protobuf and Thrift save space by
replacing field names w/ in[tegers].

When comapred to protobuf and thrift, avro saves space by
[not writing anything||"not writing anything" or "writing"]
related to the field name (though this require the schema
to be shipped separately).

*** Item                                                            :drill:
SCHEDULED: <2022-08-06 sáb>
:PROPERTIES:
:DATE_ADDED: [2022-07-29 sex]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::11:31366]]
:ID:       bf3c9441-59b4-44fc-9a22-9ae72d59b23f
:DRILL_LAST_INTERVAL: 3.998
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-08-02 ter 13:20]
:END:
:LOGBOOK:
- Refiled on [2022-07-29 sex 17:07]
:END:


Which encoding protocol advertises better experience with dynamically
generated schemas (e.g.: db dumps)? protobuf, thrift, or avro?

[avro]
*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-08-02 ter]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::11:36564]]
:END:

the most common ways how data flows between processes:

– Via dat[abases]

– Via service calls (e.g.: R[EST] and R[PC])

– Via asynchronous me[ssage] passing

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-08-02 ter]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::11:43332]]
:END:

This way of building applications has traditionally been called a
service-oriented architecture (SOA), more recently refined and
rebranded as mic[roservices] architecture

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-08-02 ter]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::11:45767]]
:END:


Which one is a protocol? REST or SOAP?

[SOAP]

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-08-02 ter]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::11:45767]]
:END:


Which one uses many HTTP features? REST or SOAP?

[REST]

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-08-02 ter]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::11:46635]]
:END:


The API of a SOAP web service is described in WSDL. The DL stands for
~Description Language~. What does WS stand for?

[Web Service].

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-08-02 ter]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::11:46942]]
:END:

WSDL enables code g[eneration] so that a client can access a remote
service using local classes and method calls (which are encoded to XML
messages and decoded again by the framework)

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-08-02 ter]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::11:47703]]
:END:

Even though SOAP and its various extensions are ostensibly
standardized, interoperability between different vendors’
implementations often causes [problems||"profit" or "problems"].

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-08-02 ter]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::11:48097]]
:END:

REST and SOAP are the latest incarnations of the idea of [remote]
[procedure] [call] (RPC).

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-08-02 ter]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::11:48609]]
:END:


The RPC model tries to make a request to a remote network service look
the same as calling a function or method in your programming language,
within the same process (this abstraction is called location
tr[ansparency]). Although RPC seems convenient at first, the approach
is fundamentally flawed. A network request is very
[different||"different" or "similar"] from a local function call:

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-08-02 ter]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::11:52147]]
:END:

gRPC is an RPC implementation using Protocol B[uffers]

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-08-02 ter]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::11:57722]]
:END:
:LOGBOOK:
- Refiled on [2022-08-02 ter 14:15]
:END:

However, a difference compared to RPC is that message-passing
communication is usually one-way: a sender normally doesn’t expect to
receive a reply to its messages. It is possible for a process to send
a response, but this would usually be done on [a separate||"the same" or "a separate"] channel.

** [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Kleppmann, Martin - Designing data-intensive applications_ the big ideas behind reliable, scalable, and maintainable systems-O'Reilly Media Inc. (2018_2017).epub::13:1][Ch. 5 - Replication]]

* [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::0:1][Time and Relational Theory (by Hugh Darwen, C.J. Date, and Nikos Lorentzos)]]
** [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::10:1][Ch 1 - Types and Relations]]
*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       bb981d1b-cef1-42db-8da1-89f41f20d132
:DRILL_LAST_INTERVAL: 4.3425
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:37]
:END:

~Relvar~ stands for re[lation] va[riable].

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       4d640c4b-f36f-49fb-b8e9-3491b645ac59
:DRILL_LAST_INTERVAL: 4.2313
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 2.5
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 17:51]
:END:

A type is a [set of values].

*** Item                                                            :drill:
SCHEDULED: <2022-08-05 sex>
:PROPERTIES:
:ID:       ef45c0c2-c8ee-4134-9683-a78c2bdb2c81
:DRILL_LAST_INTERVAL: 11.214
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:18]
:END:

Every value is of [exactly one|| "exactly one" or "one or more"]
types.

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       6abd658f-66a3-49ee-8b69-673a4a2c534d
:DRILL_LAST_INTERVAL: 4.3737
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:35]
:END:

Types can be sc[alar] and nonsc[allar], as well as us[er] defined and
sy[stem] defined.

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       c50ddecc-6076-4557-946f-8bee24da878a
:DRILL_LAST_INTERVAL: 4.3505
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 17:51]
:END:

*Definition of tuples in relational theory*

Let T1, T2, …, Tn (n ≥ 0) be *type names*, not necessarily all
distinct. Associate with each Ti a distinct *attribute name*, Ai; each
of the n ~attribute-name : type-name~ pairs that results is an
att[ribute]. Associate with each attribute Ai an *attribute value*,
vi, of type Ti; each of the n ~attribute : value~ pairs that results
is a comp[onent]. Then the *set* - call it t - of all n components
thus defined is a *tuple value* (or just a tuple for short) over the
attributes A1, A2, …, An. The value n is the deg[ree] of t; The set H
of all n attributes is the hea[ding] of t.

*** Item                                                            :drill:
SCHEDULED: <2022-08-05 sex>
:PROPERTIES:
:ID:       2cca3d07-da5a-48f5-a548-014da155ce80
:DRILL_LAST_INTERVAL: 11.3738
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:21]
:END:

*Definition of relation*

Let H be a tuple heading, and let t1, t2, …, tm (m ≥ 0) be distinct
tuples all with heading H. Then the *combination* - call it r - of H
and the set of tuples {t1, t2, …, tm} is a rel[ation] value (or just a
rel[ation] for short) over the attributes A1, A2, …, An, where A1, A2,
…, An are all of the attributes in H. The heading of r is H; r has the
same attributes (and hence the same attribute names and types) and the
same deg[ree] as that heading does. The set of tuples {t1, t2, …, tm} is
the bo[dy] of r. The value m is the card[inality] of r.

*** Item                                                            :drill:
SCHEDULED: <2022-08-05 sex>
:PROPERTIES:
:ID:       b8a5d624-b9ac-4b6d-a1ad-54900e55cd61
:DRILL_LAST_INTERVAL: 11.1588
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:25]
:END:

The predicate corresponding to relation r is the relation pred[icate]
for r. Further, each tuple in the body of r can be regarded as
denoting a certain prop[osition].

**** More

We can say the predicate corresponding to a given relation is the
intended interpretation, or meaning, for that relation. And the
propositions corresponding to tuples appearing in that relation are
understood by convention to be ones that evaluate to TRUE.

*** Item                                                            :drill:
SCHEDULED: <2022-07-31 dom>
:PROPERTIES:
:ID:       3d8fce34-5cbb-4b42-908a-6071ee904660
:DRILL_LAST_INTERVAL: 11.557
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:09]
:END:

A type is sc[alar] if it has no user visible components and nonscalar
otherwise.

**** More

Examples of nonscalar types are: tuples and relations.

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       d26ac10e-b219-494a-b876-b883b4f241d7
:DRILL_LAST_INTERVAL: 11.451
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:04]
:END:

#+begin_src
TYPE POINT /* geometric points in two-dimensional space */

   POSSREP CARTESIAN { X RATIONAL, Y RATIONAL … }

   POSSREP POLAR { RHO RATIONAL, THETA RATIONAL … } ;
#+end_src

Both ~Polar~ and ~Cartesian~ are pos[sible] rep[resentation] for the
type ~Point~.

*** Item                                                            :drill:
SCHEDULED: <2022-08-04 qui>
:PROPERTIES:
:ID:       5722e2bf-cf83-46ce-9c17-f1d455966d85
:DRILL_LAST_INTERVAL: 10.3802
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:18]
:END:

Every type definition includes, implicitly or explicitly, a
corresponding type con[straint], which is a specification of the set
of values that make up that type

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       b838a08e-f6b7-48b3-a117-447909fa7710
:DRILL_LAST_INTERVAL: 11.3627
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:03]
:END:

Differences between a table and a relation:

- No relation ever contains any du[plicate] tuples
- There’s no t[op] to bo[ttom] ordering to the tuples of a relation
- There’s no le[ft] to ri[ght] ordering to the attributes of a tuple or
  relation
- relations never contain nu[lls]

*** Item                                                            :drill:
SCHEDULED: <2022-08-03 qua>
:PROPERTIES:
:ID:       8e1e0bce-b9b0-47c7-8d3a-67c0cfeca757
:DRILL_LAST_INTERVAL: 14.6502
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:04]
:END:

There are exactly two nullary relations, one that contains just one
tuple (necessarily with no components, and hence a nullary tuple or
0-tuple—see the bullet item immediately following), and one that’s
empty and thus contains no tuples at all.  We refer to these two
relations colloquially as TABLE_DE[E] and TABLE_DU[M].

*** Item                                                            :drill:
SCHEDULED: <2022-08-02 ter>
:PROPERTIES:
:ID:       6f495188-8296-4ac7-a993-0835c6fcf540
:DRILL_LAST_INTERVAL: 13.5328
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:09]
:END:

If relation r has heading H, then that relation r is of type RELATION
H

RELATION here is a type gen[erator]

*** Item                                                            :drill:
SCHEDULED: <2022-08-01 seg>
:PROPERTIES:
:ID:       7a41c89b-cd78-4784-b08c-607cb8774095
:DRILL_LAST_INTERVAL: 13.407
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:11]
:END:

The Cl[osed] Wo[rld] Assumption (CWA) states that If relation r has
predicate P, then the body of r contains all and only those tuples
that correspond to instantiations of P that evaluate to TRUE.

** [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::11:1][Ch 2 - Relational Algebra]]
*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       59bb2342-3f56-40b4-91b1-0d749e0c1ed6
:DRILL_LAST_INTERVAL: 5.147
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:33]
:END:

The relational model includes an open ended [set||"set" or "list"] of
generic read-only operators known collectively as the relational
al[gebra].

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       12f7b2bd-814e-467b-b773-9d5244198e56
:DRILL_LAST_INTERVAL: 5.0342
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:27]
:END:

Relations r1 and r2 are joinable if and only if attributes with the
same name are of the [same||"same" or "different"] type.

*** Item                                                            :drill:
SCHEDULED: <2022-08-08 seg>
:PROPERTIES:
:ID:       538fd73a-da1d-4d2f-ae2e-7b1b9826db00
:DRILL_LAST_INTERVAL: 13.7543
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:24]
:END:

Is it the case that group and ungroup operators are always the inverse
of one another?

[No].

**** More

that given some relation r and some grouping of r, there’s always an
inverse ungrouping that yields r again; however, the converse isn’t
necessarily so.

*** Item                                                            :drill:
SCHEDULED: <2022-08-04 qui>
:PROPERTIES:
:ID:       3d4895a5-e652-4a73-9248-5b800ca291dd
:DRILL_LAST_INTERVAL: 10.3558
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.667
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:24]
:END:

Relational completeness is a basic measure of the expressive
capability of a language. If a language is relationally complete, then
it means—speaking very loosely, please note!—that queries of arbitrary
complexity can be formulated in that language [without|| "with" or
"without"] having to resort to branching or iterative loops.

**** More

And in order to be relationally complete, it’s sufficient that the
language in question support, directly or indirectly, all of the
following operators: restriction, projection, JOIN, UNION, NOT
MATCHING, and EXTEND (first version), together with the relational
inclusion operator “⊆”

| Operator                        | Example in Relational Algebra | Example in Tutorial D                   |
| Rename                          | r RENAME {A AS B}             | SP RENAME { SNO AS SNUM , PNO AS PNUM } |
| Restrict                        | r WHERE bx                    |                                         |
| Project                         | r{A1,A2,…,An}                 |                                         |
| Union                           | r1 UNION r2                   |                                         |
| Intersect                       | r1 Intersect r2               |                                         |
| Minus                           | r1 Minus r2                   |                                         |
| Disjoint Union                  |                               |                                         |
| Included Minus                  |                               |                                         |
| Join                            |                               |                                         |
| Matching                        |                               |                                         |
| Not Matching                    |                               |                                         |
| Extend (adding new attribute)   |                               |                                         |
| Extend (changing existing one)  |                               |                                         |
| Image relation                  |                               | EXTEND S : { PNO_REL := !!SP }          |
| Group and Ungroup               |                               |                                         |
| Wrap and Unwrap                 |                               |                                         |
| With (syntactic sugar)          |                               |                                         |

** [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::12:1][Ch 3 - Relation Varibles]]
*** Item                                                            :drill:
SCHEDULED: <2022-08-11 qui>
:PROPERTIES:
:ID:       7de98f0b-5c1b-496b-9ec6-5ac4c00cf052
:DRILL_LAST_INTERVAL: 14.6958
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-27 qua 12:56]
:END:

Are "relation values" and "relation variables" the same thing?

[No.]

Certain properties commonly thought of as properties of relation
v[alues]—e.g., the property of having keys, and the property of
possibly having foreign keys, and most especially the property of
being updatable—are more correctly seen as properties of relation
v[ariables] instead.

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       ba1299e2-0202-4ea1-8841-dc5f575f6051
:DRILL_LAST_INTERVAL: 4.6489
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:31]
:END:

Are the operators INSERT, DELETE, and UPDATE part of relational
algebra?

**** More

these operators (as well as relational assignment), since they’re all
update operators, aren’t operators of the relational algebra as such
(recall from Chapter 2 that the operators of the relational algebra
are all, by definition, *read-only* operators specifically)

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       58d73db1-09e8-4769-b7e3-4f39568fbcdd
:DRILL_LAST_INTERVAL: 4.6669
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:27]
:END:

The *Assignment Principle* states that after assignment of value v to
variable V, the comparison v = V must evaluate to [TRUE|| "True" or
"False"].

*** Item                                                            :drill:
SCHEDULED: <2022-08-10 qua>
:PROPERTIES:
:ID:       ac6afb12-5054-4dba-9897-e0488bbe165f
:DRILL_LAST_INTERVAL: 14.0583
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-27 qua 12:55]
:END:

Definition: Let K be a subset of the heading of relvar R. Then K is a
key (also known as a candidate key) for R if and only if it possesses
both of the following properties:

1.  Uni[queness]: No relation that can legally be assigned to R has
   two distinct tuples with the
same value for K.

2.  Irr[educibility]: No proper subset of K has the uniqueness property.

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       ab603dbd-95b8-4809-a37e-c5b0da9a9b52
:DRILL_LAST_INTERVAL: 4.0391
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:33]
:END:

Let X and Y be subsets of the heading of relvar R. Then the
fun[ctional] dep[endency] X→Y holds in R if and only if, in every
relation that’s a possible value of R, whenever two tuples have the
same value for X, they also have the same value for Y.

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       e09fbed9-cede-4871-b752-6d8be6e06ad1
:DRILL_LAST_INTERVAL: 4.1898
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:37]
:END:

Another name for foreign key constraint is ref[erential] constraint.

The rule that no foreign key constraint must ever be violated is the
ref[erential] int[egrity] rule.

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       5cb823f1-e3f4-457a-aedb-fb6d167946db
:DRILL_LAST_INTERVAL: 4.8165
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:38]
:END:

This requirement (i.e., that constraint violations be detected
immediately) is sometimes called *The Gol[den] Rule*. Observe that
it’s a consequence of this rule that no user [ever||"sometimes" or "ever"]
sees the database in an inconsistent state.

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       110ed85e-7680-4fc3-8d98-c2b336e47932
:DRILL_LAST_INTERVAL: 4.1313
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:26]
:END:

Database constraints do apply specifically to [relvars||"relvars" or "relation"].

**** More

Why? Because, by definition, the only way they can be violated is by
means of some update operation—and, again by definition, updates apply
to variables, not values.

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       32800aeb-d5e5-4acb-ba41-30ae42fb1ce7
:DRILL_LAST_INTERVAL: 5.342
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:28]
:END:

In the double assignment assignment, constraint checking is done [at the end of the statement|| "at the end of the statement" or "in between each statement"].

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       539af08d-e7d4-407d-a224-7d66a8f08554
:DRILL_LAST_INTERVAL: 4.039
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:41]
:END:

Definition: The Principle of Interchangeability (of views and base
relvars) states that there [must be no||"can be" or "must be no"]
arbitrary and unnecessary distinctions between base relvars and views;

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       d770d7d1-4f94-4aa1-a367-6dcad7107e81
:DRILL_LAST_INTERVAL: 4.5868
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:32]
:END:

Definition: The relational model consists of five components:

1.  An open ended collection of ty[pes], including type BOOLEAN in
   particular

2.  A relation type gen[erator] and an intended interpretation for
   relations of types generated
thereby

3.  Facilities for defining relation var[iables] of such generated
   relation types

4.  A relational ass[ignment] operator for assigning relation values
   to such relation variables

5.  A relationally com[plete], but otherwise open ended, collection of generic relational
ope[rators] for deriving relation values from other relation values

** [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::15:1][Ch 4 - Time and the Database]]
*** Item                                                            :drill:
SCHEDULED: <2022-07-31 dom>
:PROPERTIES:
:DATE_ADDED: [2022-07-25 seg]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::15:1455]]
:ID:       33b473ce-7898-4292-a7e3-82dcf450237c
:DRILL_LAST_INTERVAL: 3.7111
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-27 qua 12:57]
:END:

A temporal database can be thought of, loosely, as a database that contains historical data
instead of or in addition to cur[rent] data.

*** Item                                                            :drill:
SCHEDULED: <2022-07-31 dom>
:PROPERTIES:
:DATE_ADDED: [2022-07-25 seg]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::15:6931]]
:ID:       472ae5b6-1a1f-4d75-b39a-00d5fc872c1c
:DRILL_LAST_INTERVAL: 4.0309
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-27 qua 12:57]
:END:

*The Information Principle (of a relational database)*

The entire information content of the database at any given time is
represented in one and only one way: The database contains only
rel[vars]

*** Item                                                            :drill:
SCHEDULED: <2022-07-31 dom>
:PROPERTIES:
:DATE_ADDED: [2022-07-25 seg]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::15:11251]]
:ID:       e41aed2b-9642-4822-9872-03dde0f47946
:DRILL_LAST_INTERVAL: 3.9684
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-27 qua 12:59]
:END:

the approach to temporal databases that we advocate
involves [no changes||"changes" or "no changes"] to the classical relational model

*** Item                                                            :drill:
SCHEDULED: <2022-07-31 dom>
:PROPERTIES:
:DATE_ADDED: [2022-07-25 seg]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::15:23459]]
:ID:       78ef5565-2510-4bfc-a53a-6cbafc7e2a22
:DRILL_LAST_INTERVAL: 4.2307
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 2.5
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-27 qua 13:00]
:END:
:LOGBOOK:
- Refiled on [2022-07-25 seg 18:40]
:END:

Which one can be updated? *valid time* or *transaction time*?

[valid time].

**** More

valid times can be updated, but transaction times can’t.
*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-27 qua]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::15:23619]]
:ID:       0ba9802e-0557-48fc-b3d5-8a010e4f05cf
:END:

Valid vs transactional time

[Valid] times reflect our beliefs about history, and those beliefs can
change; [transaction] times, by contrast, reflect history as such, and
history can’t change

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-27 qua]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::15:25047]]
:ID:       cdc8a6ca-7b5d-4354-8c86-deb7f51bc8da
:END:

by adopting the assumption—except briefly in Appendix B—that the
“timeline” consists of a finite contiguous sequence of discrete
indivisible time qua[nta] (where a time quantum is the smallest time
unit the system is capable of representing).

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-27 qua]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::15:28943]]
:ID:       5f0c49bd-b445-4649-a971-84a468c1e609
:END:


In an rdbms, the timeline is a [finite||"infinite" or "finite"]
sequence of discrete points.

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-27 qua]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::15:30157]]
:ID:       f6349838-faa2-4ec9-860e-9a3ed8d49516
:END:

In time relational theory, we take *during* to mean “throughout [and not||"and not" or "and"] immediately before or immediately after (the
interval in question).” In similar fashion, we take *since* to mean
“ever since [and not||"and" or "and not"] immediately before (the point in question).”

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-27 qua]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::15:371]]
:ID:       03f312b4-fbbb-45c9-a985-9b19a4609afb
:END:


In time relational theory, it is important to be clear about the
intended meaning of a time range column. 3 prepositions are useful to
describe these columns: on, sin[ce], and dur[ing]

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-27 qua]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::15:8096]]
:ID:       0dbd1ddc-f19e-45bc-97d9-d9fb41cce35e
:END:
:LOGBOOK:
- Refiled on [2022-07-27 qua 17:34]
:END:

time[stamped] propositions—by which we mean propositions that involve
one or more values of some timestamp type
** Ch 5 - What is the problem?

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-08-02 ter]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::16:23713]]
:END:
:LOGBOOK:
- Refiled on [2022-08-02 ter 14:33]
:END:

the problem of temporal data is that it quickly leads to constraints
and queries that are [unreasonably complex||"unreasonably complex" or "too easy"]
to express

** Ch 5 - Intervals


*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-08-02 ter]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::17:4005]]
:END:


What is the predicated for a reval that has string member ~SNO~ and
interval member ~during~?

Supplier SNO was under contract throughout the interval from the day
that’s the begin point of DURING to the day that’s the end point of
DURING, inclusive, and not throughout any interval that *properly*
in[cludes] that interval.

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-08-02 ter]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::17:14209]]
:END:

Definition: Type T is usable as a point type if all of the following are defined for it: 

- a.  A [total||"total" or "partial"] ordering
- b.  Niladic *first* and *last* operators, which return the smallest
  (first) and largest (last) value of type T, respectively, according
  to the aforementioned ordering
- c.  Monadic *next* and *prior* operators, which return the successor
  (if it exists) and predecessor (if it exists), respectively, of any
  given value of type T according to the aforementioned ordering

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-08-02 ter]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Databases/Darwen, Hugh_Date, C.J._Lorentzos, Nikos - Time and Relational Theory-Elsevier Science_Morgan Kaufmann (2014).epub::17:18817]]
:END:
:LOGBOOK:
- Refiled on [2022-08-02 ter 15:25]
:END:

Definition: Let T be a point type. Then an interval value (or just an
interval for short) i of type INTERVAL_T is a value for which two
monadic operators, BEGIN and END, and one dyadic operator, “∈”, are
defined, such that:

- a.  BEGIN (i) and END (i) both return a value of type [T].

- b.  BEGIN (i) [≤||"<" or "≤"] END (i).

- c.  If p is a value of type T, then ~p ∈ i~ is true if and only if BEGIN (i) ≤ p and p ≤ END (i) are both [true||"false" or "true"].
* [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::0:1][The Art of Immutable Architecture]]
** Ch 1 - Why Immutable Architecture
*** Item                                                            :drill:
SCHEDULED: <2022-07-31 dom>
:PROPERTIES:
:ID:       eaafd759-959b-411b-b866-53cf53b07e51
:DRILL_LAST_INTERVAL: 12.2164
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:09]
:END:

Common fallacies of distributed systems:

– The network is re[liable].
– Latency is ze[ro].
– Bandwidth is in[finite].
– The network is se[cure].
– To[pology] doesn’t change.
– There is one ad[ministrator].
– Transport cost is ze[ro].
– The network is homo[geneous].

*** Item                                                            :drill:
SCHEDULED: <2022-08-02 ter>
:PROPERTIES:
:ID:       c7c6836c-88ca-4e26-9836-ae954afeaf47
:DRILL_LAST_INTERVAL: 13.7722
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:09]
:END:

As we build new data structures, we can reuse existing pieces of old
data structures. There is no need to copy those pieces, because we
have already established that they will not change. We simply create
new data elements to represent the ones that have “changed” and let
them point to the ones that haven’t.

This is a technique called str[uctural] sh[aring]. It’s a common
optimization for immutable data structures that is enabled by
immutable data structures.

*** Item                                                            :drill:
SCHEDULED: <2022-07-31 dom>
:PROPERTIES:
:ID:       f8aa8ae1-ad7b-4968-86d4-1860a39bca65
:DRILL_LAST_INTERVAL: 12.2566
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:02]
:END:

The Two Generals’ Problem (TGP), as Jim Gray named it in 19783, has
been proven to have [zero||zero,one,two, ...] solutions.

*** Item                                                            :drill:
SCHEDULED: <2022-08-02 ter>
:PROPERTIES:
:ID:       99b767cc-b170-493e-9865-2a8a6fc5b5b4
:DRILL_LAST_INTERVAL: 14.3294
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:10]
:END:

Given the impossibility of the TGP, how can distributed systems ever
work?

We can indeed find a protocol that exchanges complete status, as long
as we allow one party to 1. act in un[certainty] and 2. remove the
de[adline].

*** Item                                                            :drill:
:PROPERTIES:
:ID:       375e568a-5e13-4304-b686-2d3d67e8a8ab
:END:
*** Item                                                            :drill:
:PROPERTIES:
:ID:       f122e300-51fb-47a0-aad8-6f08551b7fdf
:END:
*** Item                                                            :drill:
:PROPERTIES:
:ID:       cc6de256-efcc-49df-a841-f502c5b6796f
:END:
*** Item                                                            :drill:
:PROPERTIES:
:ID:       e865d3ef-b20f-43b5-bb89-f9f51da3bfd9
:END:
*** Item                                                            :drill:
SCHEDULED: <2022-08-08 seg>
:PROPERTIES:
:ID:       387f756a-076a-4971-ace9-106817410f4e
:DRILL_LAST_INTERVAL: 10.3877
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:09]
:END:

As you learn to model business problems based on immutability, you
will start to enjoy the advantages of a reliable audit[able] history, just
like blockchain. And as you learn to implement immutable data
structures within your mobile apps and microservices, you will benefit
from the same auton[omy] found in Git.

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       03012db5-2641-42d1-848f-b58475b143ba
:DRILL_LAST_INTERVAL: 4.5472
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:26]
:END:

A saying:

Immutability Ch[anges] Everything

** [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::5:1][Ch. 2 - Forms of Immutable Architecture]]
*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       b0cd1781-e57f-4f18-bf08-9378ea42c0b7
:DRILL_LAST_INTERVAL: 4.6488
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:38]
:END:

*Object vs record*

We will call the things that change X, and the things that do not
change Y.

**** More

- X = object
- Y = record

*** Item                                                            :drill:
SCHEDULED: <2022-08-08 seg>
:PROPERTIES:
:ID:       630a07e9-0200-4c06-bfa2-2fc6121a4823
:DRILL_LAST_INTERVAL: 12.3821
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-27 qua 12:56]
:END:

The trade-offs requiring shift to immutability have led to the
emergence of different architectural styles. Three of those styles:
Ev[ent] Sou[rcing] (ES), Asynchronous Mo[del] Vi[ew] Up[date], and
His[torical] Mod[eling].

*** Item                                                            :drill:
SCHEDULED: <2022-08-06 sáb>
:PROPERTIES:
:ID:       73a57cc2-bed6-4ba9-b876-e1e96a76c78a
:DRILL_LAST_INTERVAL: 12.0357
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:24]
:END:

An *identity* in object-oriented programming describes the property of
objects that disti[nguishes] them from other objects.

The reason for an object to have intrinsic identity is so that it can
provide consi[stent], mea[ningful] behavior as it changes over time.

*** Item                                                            :drill:
SCHEDULED: <2022-08-12 sex>
:PROPERTIES:
:ID:       6468a5bc-251c-458a-92ac-6abaab089263
:DRILL_LAST_INTERVAL: 15.5581
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-27 qua 12:54]
:END:

Our goal now is to use immutable records to model mutable objects. The
records clearly are not the objects themselves. The immutable records
are the mut[ations] of the objects.

We will treat immutable records as obs[erved] state. Objects, on the
other hand, are der[ived] state.

*** Item                                                            :drill:
SCHEDULED: <2022-08-07 dom>
:PROPERTIES:
:ID:       5e6ed3fc-a5da-430b-8f69-813a46e11323
:DRILL_LAST_INTERVAL: 12.8135
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:18]
:END:

Der[ived] state is a deterministic transformation of obs[erved] state. It
adds no information to the system.

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       ffbb7d40-0a7b-44ce-87e4-60ea4cd3734a
:DRILL_LAST_INTERVAL: 4.8583
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:28]
:END:

The fundamental idea of Event Sou[rcing] is that of ensuring every
change to the state of an application is captured in an event object,
and that these event objects are themselves stored in the seq[uence]
they were applied for the same lifetime as the application state
itself.

*** Item                                                            :drill:
SCHEDULED: <2022-08-09 ter>
:PROPERTIES:
:ID:       bca45729-dc10-436f-9f3f-3d4af58ab08d
:DRILL_LAST_INTERVAL: 10.6962
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:09]
:END:

I therefore consider seq[uence] a defining characteristic of event
sourcing.

*** Item                                                            :drill:
SCHEDULED: <2022-08-06 sáb>
:PROPERTIES:
:ID:       98e6eb13-1dd1-4e32-84db-50a9c6c5d34b
:DRILL_LAST_INTERVAL: 11.8041
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:20]
:END:

Practitioners will often pair event sourcing with both Command Query
Responsibility Seg[regation] (CQRS) and Domain-Driven Des[ign]
(DDD). This pairing is not a requirement for ES, nor are the
implementations all in agreement how it is achieved

*** Item                                                            :drill:
SCHEDULED: <2022-08-10 qua>
:PROPERTIES:
:ID:       897a252d-1f1c-4413-906d-cfa383245916
:DRILL_LAST_INTERVAL: 14.0826
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-27 qua 12:56]
:END:

Command Query Responsibility Segregation extends the object-oriented
principle of Command Query Separation (CQS).

A com[mand] serves to modify objects, a qu[ery] to return information
about objects

*** Item                                                            :drill:
SCHEDULED: <2022-08-05 sex>
:PROPERTIES:
:ID:       821138d9-7c6c-401b-976a-d665b2bd5d5f
:DRILL_LAST_INTERVAL: 10.523
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:22]
:END:

In CQRS , commands and queries follow separate pa[ths] and often
interact with different architectural com[ponents]. Co[mmands] are
often asynchronous, while qu[eries] are usually synchronous. In many
implementations, they operate against different data stores.

*** Item                                                            :drill:
SCHEDULED: <2022-08-07 dom>
:PROPERTIES:
:ID:       71c95800-400c-4851-8599-50d92b90fde5
:DRILL_LAST_INTERVAL: 12.6659
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:20]
:END:

When CQRS is paired with ES, commands are further distinguished from
events. Whereas a command is expressed as an im[perative] statement,
an event is a pa[st]-tense statement. The command ~SubmitOrder~ results
in the event ~OrderSubmitted~.

*** Item                                                            :drill:
SCHEDULED: <2022-08-08 seg>
:PROPERTIES:
:ID:       7f338347-cd6a-4d25-a884-e6ec2a9d7f74
:DRILL_LAST_INTERVAL: 14.4619
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:25]
:END:

DDD recognizes two kinds of objects: entities and value types. An
en[tity] is an object that has identity. As we have already seen,
object-oriented identity affords the object the ability to change over
time. In contrast, a va[lue] type has no identity and is therefore
immutable.

*** Item                                                            :drill:
SCHEDULED: <2022-08-09 ter>
:PROPERTIES:
:ID:       d95f44bc-0f92-486c-8710-3a4ae43403b0
:DRILL_LAST_INTERVAL: 10.9582
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:12]
:END:

For efficiency of recomputing the current state, Event sourced
applications break that history into independent *streams*, each
stream affecting only a subset of the domain model. *When ES is
combined with DDD*, that subset is the agg[regate] ro[ot].

*** Item                                                            :drill:
SCHEDULED: <2022-08-07 dom>
:PROPERTIES:
:ID:       9def188d-fe8e-4c07-959c-b922d90eca1a
:DRILL_LAST_INTERVAL: 13.2175
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:23]
:END:

Entities in DDD are organized within hierarchies called agg[regates]. An
aggregate is a parent–child relationship. At the top of this hierarchy
is the aggregate ro[ot].

*** Item                                                            :drill:
SCHEDULED: <2022-08-05 sex>
:PROPERTIES:
:ID:       e56cd436-e0d5-4526-a404-2a9358ef2ff9
:DRILL_LAST_INTERVAL: 11.4276
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:20]
:END:

Since event sourcing is based on a seq[uence] of operations, it is
sensitive to both order and duplication. It is up to the application
developer to ensure that order is preserved and duplicates are
prevented.

*** Item                                                            :drill:
SCHEDULED: <2022-08-09 ter>
:PROPERTIES:
:ID:       49f2dbd5-bf01-499b-b614-86c7271ffc6d
:DRILL_LAST_INTERVAL: 13.4039
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-27 qua 12:56]
:END:

The pattern on which Elm is based is called Model View Up[date] .

**** More

Contrast it to: MVC

*** Item                                                            :drill:
SCHEDULED: <2022-08-07 dom>
:PROPERTIES:
:ID:       63cc05f9-be0f-473b-affb-347e6c88daa8
:DRILL_LAST_INTERVAL: 13.336
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:19]
:END:

In MVC, a cont[roller] responds to changes in the model by updating
the views. It also responds to user input in the view by updating the
model. The controller coordinates data flow in [two||one, two, ...]
directions.

**** More

The 2 directions are: both in from the user and outward from the
application.

*** Item                                                            :drill:
SCHEDULED: <2022-08-09 ter>
:PROPERTIES:
:ID:       8971109e-309b-47f0-bbe9-033c8a4084b6
:DRILL_LAST_INTERVAL: 13.4974
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-27 qua 12:55]
:END:

The problem with bidirectional data flow (e.g. in MVC where 2
controllers can depend on one another) is that it is difficult to know
whether a new feature is going to produce either of 1.  cas[cading]
updates or 2. cir[cular] dependencies.

*** Item                                                            :drill:
SCHEDULED: <2022-08-06 sáb>
:PROPERTIES:
:ID:       30b9c58d-3764-4ec3-991d-ad98ff64789f
:DRILL_LAST_INTERVAL: 12.0239
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:21]
:END:

Asynchronous Model View Update is similar to elm's model-view-update,
but extended to work across machines (e.g.: client and server). It
adds a qu[eue] to the client. Plus state updates are opt[imistically]
computed on the client, plus sent to the server. The true state is the
one in the [server||client or server].

*** Item                                                            :drill:
SCHEDULED: <2022-08-06 sáb>
:PROPERTIES:
:ID:       fd192966-5857-4cae-83e7-b80b957481e4
:DRILL_LAST_INTERVAL: 12.4536
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:19]
:END:

The Asynchronous Model View Update architecture optimistically
interprets a series of actions.  User actions are validated on-device
with the expectation that most of them will succeed on the server. It
is assumed that [no other||"other" or "no other"] actions will
intervene and that the result of executing the actions on the server
will be [the same as|| "different than" or "the same as" ] on the
client. When this optimistic assumption is found to be false, the
architecture simply dis[cards] the locally computed state and takes
the server’s version.

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       c211bf41-bd88-4827-8185-b69f267b21d3
:DRILL_LAST_INTERVAL: 4.5274
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:27]
:END:

Properties of both partial and total order:

- tra[nsitive]: a<b and b<c ⇒ a<c
- non re[flexive]: a≮a
- unid[irectional]: a<b ⇒ b≮a

In a total order, for a and b distinct:

- a≮b ⇒ [b<a]

*** Item                                                            :drill:
SCHEDULED: <2022-08-13 sáb>
:PROPERTIES:
:ID:       2c5878b0-1339-43d9-b19a-63c0ae5784cc
:DRILL_LAST_INTERVAL: 15.2751
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:12]
:END:

The way in which Historical Modeling puts facts into a partial order
is to identify pred[ecessors] .

*** Item                                                            :drill:
SCHEDULED: <2022-08-09 ter>
:PROPERTIES:
:ID:       2d518cf9-b70d-4da3-9377-0485a75a8c6a
:DRILL_LAST_INTERVAL: 12.8784
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-27 qua 12:55]
:END:

A fact does not know about its successors . New successors are added
over time. To fully understand the state of a fact, we must query the
historical model to discover if new suc[cessors] have been created.

*** Item                                                            :drill:
SCHEDULED: <2022-08-12 sex>
:PROPERTIES:
:ID:       6ad2e891-3a96-47e0-893b-cad9e82f215d
:DRILL_LAST_INTERVAL: 16.3391
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-27 qua 12:55]
:END:

Since a fact refers to its predecessors , and the fact is immutable,
it follows that a predecessor [cannot||cannot or can] be added to an
existing fact.

*** Item                                                            :drill:
SCHEDULED: <2022-08-07 dom>
:PROPERTIES:
:ID:       f2eaf78c-e740-42c4-a1c4-4181bf4897b8
:DRILL_LAST_INTERVAL: 12.5496
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.667
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:18]
:END:

The transitive clo[sure] identifies the starting fact. There is no
other fact for which the transitive clo[sure] would produce this same
set. In a historical model, this is the only way to identify a fact.

**** More

They do not have globally unique identifiers (GUIDs) or sequence
numbers outside of this structure. The contents of the facts in the
transitive closure are all you’ve got to tell one fact apart from
another.

*** Item                                                            :drill:
SCHEDULED: <2022-08-05 sex>
:PROPERTIES:
:ID:       4406e716-3800-4915-bf9f-7f2305d296f8
:DRILL_LAST_INTERVAL: 10.7701
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:22]
:END:

In *Historical Modeling*, the immutability of facts constrains them to
know their predecessors at the time of creation.  But there are two
more constraints that we have to put on the system. We must disallow
both sim[ultaneous] creation and self-ref[erence], lest we introduce
cycles.

*** Item                                                            :drill:
SCHEDULED: <2022-08-02 ter>
:PROPERTIES:
:ID:       d8e751a6-680b-4ca9-80af-386d6f9fef65
:DRILL_LAST_INTERVAL: 8.0024
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:22]
:END:

On *Historical Modeling*, for every party in the system to eventually
reach the same conclusion, that conclusion [cannot|| "must" or
"cannot"] be based on timeliness.

**** More

Only by arbitration of a central authority can these situations be
resolved.

*** Item                                                            :drill:
SCHEDULED: <2022-08-11 qui>
:PROPERTIES:
:ID:       add38a56-03fd-48b8-83f3-13c643bd43d7
:DRILL_LAST_INTERVAL: 12.6188
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:10]
:END:

In Historical Modeling, At best, we can speak of failure of
information to arrive at a certain place by a certain time. But we
[cannot|| "can" or "cannot"] prove that the information did not exist
somewhere else at that time. And when the fact arrives later, we must
decide how we are to react to it.

*** Item                                                            :drill:
SCHEDULED: <2022-08-09 ter>
:PROPERTIES:
:ID:       d15d0abd-a5f5-4f33-8eeb-bb6f498799f1
:DRILL_LAST_INTERVAL: 13.3672
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-27 qua 12:56]
:END:

Should one use historical modeling for a system that must reserve the
use of scarce resources?

[Probably not].

**** More

When a reservation is approved, the approver needs to know that no
other reservation for the same room at the same time has been
approved. That decision must be made by a central authority.

*** Item                                                            :drill:
SCHEDULED: <2022-08-11 qui>
:PROPERTIES:
:ID:       dccbda35-0cf0-41de-b08d-b2a8e0ab75ae
:DRILL_LAST_INTERVAL: 12.8336
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:11]
:END:

Is there any room for a historical model on a system that requires
central authority to define strict usage of scarce resources?

Yes, at the ed[ges] of the central authority.

**** Answer

The historical model can capture the fact that a request has been
made,as well as capture the fact that a request was approved.

*** Item                                                            :drill:
SCHEDULED: <2022-08-08 seg>
:PROPERTIES:
:ID:       707a6b28-0b30-408b-89e7-aa370c85dcfb
:DRILL_LAST_INTERVAL: 9.9185
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:10]
:END:

A domain that requires at most one result [cannot|| can or cannot]
effectively be modeled historically.

**** More

For example, a login that requires a unique user name should be
supported by a static model.  A historical model would be unable to
enforce the uniqueness of a user name.

*** Item                                                            :drill:
SCHEDULED: <2022-08-06 sáb>
:PROPERTIES:
:ID:       6380d48f-ad5b-4c07-8640-6856b68d9daa
:DRILL_LAST_INTERVAL: 11.9157
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:24]
:END:

Limitations of historical modeling:

- no central authority
- no real time clock
- no uniq[ueness] constraint
- no agg[regation]

*** Item                                                            :drill:
SCHEDULED: <2022-08-10 qua>
:PROPERTIES:
:ID:       7220fbc1-173b-44c3-a666-8b62455524c7
:DRILL_LAST_INTERVAL: 11.6592
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:11]
:END:

When designing a system that requires aggregates over history, add a
sta[tic] model—whether singular or sharded—to the historical one.

**** More

Model individual transactions historically. At a central authority,
collect a list of ongoing historical facts into the static model. At
regular intervals, close the tally of facts and compute a summary.

*** Item                                                            :drill:
SCHEDULED: <2022-08-08 seg>
:PROPERTIES:
:ID:       0e9eb6da-781a-4c59-9ac9-ac7ed7932af0
:DRILL_LAST_INTERVAL: 9.5803
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:10]
:END:

The distinctive characteristic of Historical Modeling(HM) when
compared to Event Sourcing and MVU is that HM [does not||"does not" or "does"] assume that
historical events occurred within a fully ord[ered] sequence.

*** Item                                                            :drill:
SCHEDULED: <2022-08-08 seg>
:PROPERTIES:
:ID:       ea8928d7-ed42-48ad-9054-1e12bc798bd2
:DRILL_LAST_INTERVAL: 10.1602
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:11]
:END:

In Historical Modeling, Instead of referring to historical records as
events or actions, let us call them fa[cts].

** [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::6:1][Ch. 3 - How to Read a Historical Model]]
*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       aaf2ab8c-2159-4603-b7a2-5ce708cd3924
:DRILL_LAST_INTERVAL: 4.9252
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:29]
:END:

The *fact type diagram* expresses both the car[dinality] and the
cau[sality] of the domain. Reading through it reveals a narrative of
how a system came to be in a particular state and exposes the
constraints on how that system can and cannot change.

*** Item                                                            :drill:
SCHEDULED: <2022-08-11 qui>
:PROPERTIES:
:ID:       ddbf7607-e4c2-4963-b429-247d3fbd4d96
:DRILL_LAST_INTERVAL: 12.562
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:11]
:END:

In a fact type diagram, the nodes are ty[pes] and the directed arrows
indicate pre[decessor] hierarchy.

On the diagram ~(A) -> (B)~, A is the [successor|| "sucessor" or "predecessor"],
and B is the [predecessor|| "sucessor" or "predecessor"].

Labels on the arrows are [optional|| "mandatory" or "optional"].

*** Item                                                            :drill:
SCHEDULED: <2022-08-12 sex>
:PROPERTIES:
:ID:       b97519c9-66a8-40ae-b981-33b483ffe8e6
:DRILL_LAST_INTERVAL: 13.6356
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:10]
:END:

On domain modeling, we can never limit the number of successors, but
we can express the number of predecessors in a few ways:

- [?] :: Zero or One
- [*] :: Zero or many
- [-] :: Exactly one

*** Item                                                            :drill:
SCHEDULED: <2022-08-09 ter>
:PROPERTIES:
:ID:       d72d6a30-5878-49b1-9bae-5e541d1e2dc7
:DRILL_LAST_INTERVAL: 11.2946
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:11]
:END:

Are loops allowed in a fact *type* diagram?

[Yes.]

**** More

Even though this relationship introduces a cycle into the fact type
graph, it does not allow cycles of fact instances.

A fact instance diagram does not admit cycles. A fact never refers to
itself as a predecessor.  Nor can facts refer to predecessors that in
turn refer to the original, directly or indirectly.

*** Item                                                            :drill:
SCHEDULED: <2022-08-02 ter>
:PROPERTIES:
:ID:       d9ae11de-2c29-49b6-af8e-5ccba9f14862
:DRILL_LAST_INTERVAL: 4.2631
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.333
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:15]
:END:

Are loops allowed in a fact *instance* diagram?

[No.]

**** More

A fact instance diagram does not admit cycles. A fact never refers to
itself as a predecessor.  Nor can facts refer to predecessors that in
turn refer to the original, directly or indirectly.

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       027b6e35-4e1f-4d21-9bb1-7ef11d58b455
:DRILL_LAST_INTERVAL: 4.6412
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:30]
:END:

Whereas fact type diagrams are general descriptions of a model, fact
instance diagrams show specific ex[amples].

**** More

They offer a form of debugging prior to a model having been implemented.

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       a017f78d-84dc-49a5-9a04-cbf1101c73f0
:DRILL_LAST_INTERVAL: 4.9942
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-25 seg 16:40]
:END:

In Historical Modeling, a fact is uniquely identified by its ty[pe],
the va[lues] of its fi[elds], and the *set* of its pred[ecessors].

*** Item                                                            :drill:
SCHEDULED: <2022-07-31 dom>
:PROPERTIES:
:DATE_ADDED: [2022-07-25 seg]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::6:23266]]
:ID:       b460a0c5-0a3f-4ef3-9278-342bbccb0d52
:DRILL_LAST_INTERVAL: 3.7923
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-27 qua 12:59]
:END:


The book Immutable Architecture proposes a textual language for modeling the domains. This languange is called Fact[ual].

*** Item                                                            :drill:
SCHEDULED: <2022-08-01 seg>
:PROPERTIES:
:DATE_ADDED: [2022-07-25 seg]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::6:35995]]
:ID:       176c96ca-d844-4aca-9537-bfcfb87a5ec3
:DRILL_LAST_INTERVAL: 5.066
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-27 qua 12:59]
:END:

What are the missing keywords?

fa[ct] Win {
  game: Game
  player: Player
  moves: Move*
}

qu[ery] cartsContainingProduct(p: Product) {
  ma[tch] ol: OrderLine where ol.price.product = p
  th[en] c: Cart where c = ol.cart
}

query currentPriceOfProduct(pr: Product) {
  match p: Price where p.product = pr
    su[ch] that not exists next: Price where next.prior = p
}

aut[horize] ol: OrderLine {
  match u: User where ol.cart.createdBy = u
}
** [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::8:1][Ch. 4 - Location Independence]]
*** Item                                                            :drill:
SCHEDULED: <2022-08-03 qua>
:PROPERTIES:
:DATE_ADDED: [2022-07-27 qua]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::8:1917]]
:ID:       d5153fbf-68c7-4d30-977b-b53c1e053e33
:DRILL_LAST_INTERVAL: 4.9623
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:14]
:END:

So many of the behaviors that we’ve come to expect from our systems
depend upon location.  We expect items to be sequ[entially] ordered. We
expect the system to reject dupl[icate] names.  We expect that when the
user updates a property of an object, it will have the value that they
just assigned. Indeed, the expectation that properties to even have
sin[gle] values is a location-dependent assumption.

*** Item                                                            :drill:
SCHEDULED: <2022-08-02 ter>
:PROPERTIES:
:DATE_ADDED: [2022-07-27 qua]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::8:4636]]
:ID:       2e375704-80ac-44dd-8301-1d23e6c39f8e
:DRILL_LAST_INTERVAL: 4.2036
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:13]
:END:

Where sync[hronization] describes the agreement of data structures
stored in different locations, caus[ality] describes the history of
the data itself, no matter where it is stored. Causality is a weaker
constraint than synchronization, but one that is much easier to
achieve.

*** Item                                                            :drill:
SCHEDULED: <2022-08-02 ter>
:PROPERTIES:
:DATE_ADDED: [2022-07-27 qua]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::8:7293]]
:ID:       6677cd18-35cf-443e-93cd-77ba66c2294a
:DRILL_LAST_INTERVAL: 4.2879
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:14]
:END:

The core of the issue is that an auto-incremented ID is generated at a
certain loca[tion]. It only has meaning within a single database

*** Item                                                            :drill:
SCHEDULED: <2022-08-03 qua>
:PROPERTIES:
:DATE_ADDED: [2022-07-27 qua]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::8:9249]]
:ID:       0d97805a-ae66-4f8c-93cf-aa0734dd6e6c
:DRILL_LAST_INTERVAL: 5.006
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:15]
:END:

Auto-incrementing IDs cross the threshold from annoyance to impediment
when we try to implement a warm standby disaster reco[very] solution,
where the goal is to have a repl[ica] of production data in a
geographically isolated datacenter to mitigate against a localized
outage. The longer we wait for the data to arrive, the longer we have
to postpone generating new IDs.

*** Item                                                            :drill:
SCHEDULED: <2022-08-03 qua>
:PROPERTIES:
:DATE_ADDED: [2022-07-27 qua]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::8:11307]]
:ID:       2c67e3dc-8f64-45fd-8670-460118db45b6
:DRILL_LAST_INTERVAL: 4.6175
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:13]
:END:

The awkwardness of using an auto-incremented ID as identity becomes
apparent when dealing with parent–child relationships. The parent
record has a primary key. The child records each have a foreign
key. The database enforces referential integrity of foreign keys, so
the parent record must be inserted [before||"after" or "before"] the
children (the parent insertion must have completed and produced the
auto-incremented ID).

*** Item                                                            :drill:
SCHEDULED: <2022-08-02 ter>
:PROPERTIES:
:DATE_ADDED: [2022-07-27 qua]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::8:15151]]
:ID:       02932289-422a-4607-8a6a-c53e9467eb31
:DRILL_LAST_INTERVAL: 4.1237
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:13]
:END:

- Uniform Resource Iden[tifier] (URI)
- Uniform Resource Loca[tors] (URLs)

A URL has the same hierarchical structure as a URI, but now it has an
additional constraint: a URL must be addressable. It must carry enough
information for an application to send a command to the ho[st] that will
execute it.

*** Item                                                            :drill:
SCHEDULED: <2022-08-03 qua>
:PROPERTIES:
:DATE_ADDED: [2022-07-27 qua]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::8:17866]]
:ID:       fdcc5d73-1519-41c6-ad13-ae9fe5743dc0
:DRILL_LAST_INTERVAL: 5.1697
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:15]
:END:


A location-independent identity has three useful properties:

– It can be generated from [any||"any" or "a specific"] node.
– It is [immutable||"mutable" or "immutable"].
– It [can||"cannot" or "can"] be compared.

*** Item                                                            :drill:
SCHEDULED: <2022-08-03 qua>
:PROPERTIES:
:DATE_ADDED: [2022-07-27 qua]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::8:20602]]
:ID:       4869e9db-39d0-40ef-8c14-88ad796ee9d7
:DRILL_LAST_INTERVAL: 4.5954
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:15]
:END:

Some nat[ural] keys are primary keys generated by an exter[nal] system. If
you are integrating with the US tax system, you will probably identify
people and companies by their tax ID.  There is usually no good reason
to generate a new identity when the system on the other end of an
integration has already provided one .

*** Item                                                            :drill:
SCHEDULED: <2022-08-02 ter>
:PROPERTIES:
:DATE_ADDED: [2022-07-27 qua]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::8:18886]]
:ID:       c3c70384-81c1-4228-a764-fd94130f988e
:DRILL_LAST_INTERVAL: 4.3056
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:12]
:END:

Probably the best example of a location-independent identity—and the
one that should be the default in any application design—is the
nat[ural] key.

*** Item                                                            :drill:
SCHEDULED: <2022-08-02 ter>
:PROPERTIES:
:DATE_ADDED: [2022-07-27 qua]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::8:20926]]
:ID:       fa74977e-5226-45c3-85f7-5f5d3dfd3b88
:DRILL_LAST_INTERVAL: 4.0704
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-29 sex 17:13]
:END:
:LOGBOOK:
- Refiled on [2022-07-27 qua 17:09]
:END:


Whether you call it a UUID or a GUID, it is a [128]-bit number
represented in hexadecimal in a hyphenated format that is recognizable
to most developers.
*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-29 sex]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::8:25746]]
:END:

A few alternatives to incremental IDs are:

- nat[ural] keys
- GUIDs
- Timestamps
- Tup[les] of the above
- Hashes of tuples
- Pub[lic] keys
- Ra[ndom] numbers

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-29 sex]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::8:35601]]
:END:

Lamport called two steps that cannot be put in order conc[urrent].

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-29 sex]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::8:38180]]
:END:

(partially vs totally order)

If you were to compare any two steps running in the same process , you
could tell which of the two came first. Those steps are [totally]
ordered.

If, however, you compare two steps running in different processes,
sometimes you can tell and sometimes you can’t, the execution of steps
in a multi-process system is said to be [partially] ordered.

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-29 sex]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::8:39590]]
:END:

The CAP Theorem relates the ideas of consistency, availability, and
partition tolerance. It is often quoted as saying you can only have
[two||"two" or "one"] of the three.

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-29 sex]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::8:41855]]
:END:

consistent in CAP is about nodes in a [distributed||"database" or "distributed"] system.

*** Item                                                            :drill:
:PROPERTIES:
:DATE_ADDED: [2022-07-29 sex]
:SOURCE: [[nov:/home/jz/Documents/Papers/Software/Design&Architecture/Michael L. Perry - The Art of Immutable Architecture_ Theory and Practice of Data Management in Distributed Systems-Apress (2020).epub::8:42954]]
:END:
:LOGBOOK:
- Refiled on [2022-07-29 sex 17:58]
:END:

CAP[ Theorem]:

No distributed system, no matter what algorithm it uses, can
simultaneously guarantee consistency, availability, and partition
tolerance at any given interval. If during that interval the network
is partitioned, then the system will either be inconsistent or
unavailable.


* Articles and Blog Posts
:LOGBOOK:
- Refiled on [2022-07-25 seg 19:34]
:END:
** [[https://fsharpforfunandprofit.com/posts/concurrency-actor-model/][Messages and Agents]] (F# for fun and profit)
*** Item                                                            :drill:
SCHEDULED: <2022-08-05 sex>
:PROPERTIES:
:ID:       8d3c2d3b-54fe-47bf-9377-7ca9c37ac0e9
:DRILL_LAST_INTERVAL: 17.3149
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:09]
:END:

What is the difference between message-base and actor-based (both in
the scope of approaches to concurrency)?

[None. They are the same]

*** Item                                                            :drill:
SCHEDULED: <2022-07-29 sex>
:PROPERTIES:
:ID:       e98cd652-0a7b-42f5-938e-7e4c74239050
:DRILL_LAST_INTERVAL: 10.3672
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:06]
:END:

On the actor-based model, each actor has its own mailbox and isolated
state. Based on its designated behavior, the actor responds to
incoming messages by se[nd] new messages, sp[awn] new actors and/or
changing its internal st[ate].

*** Item                                                            :drill:
SCHEDULED: <2022-08-02 ter>
:PROPERTIES:
:ID:       138c586c-4397-4e88-a89e-bbc70a1c750b
:DRILL_LAST_INTERVAL: 13.6423
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:10]
:END:

In the actor-based modeling, messages are sent as[ynchronously] and
can take arbitrarily long to eventually arrive in the mailbox of the
receiver. Also, the actor models makes no guarantees on the or[dering]
of messages

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       490dc4e4-1734-4a11-a3b0-99b795eba4ba
:DRILL_LAST_INTERVAL: 10.8807
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:05]
:END:

Despite being lock free, can concurrency issues still happen on a
system developed w/ the actor model?

[Yes. concurrency issues like deadlocks and race conditions are still
not entirely expelled in this programming model, as they can be
reintroduced by incorrect applications.]

*** Item                                                            :drill:
SCHEDULED: <2022-07-31 dom>
:PROPERTIES:
:ID:       f381e7e5-600d-4ae8-bda3-595837b59a7b
:DRILL_LAST_INTERVAL: 12.2989
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:10]
:END:

When building a web app with the actor model, Often, the flow of a
single request represents a more or less complex message flow between
multiple actors, using messaging pa[tterns] such as scatter/gather,
router, enricher or aggregator

** [[https://mattferderer.com/what-is-the-actor-model-and-when-should-you-use-it/][What is the Actor Model & When Should You Use it?]]

*** Item                                                            :drill:
SCHEDULED: <2022-08-02 ter>
:PROPERTIES:
:ID:       5652d00e-9f90-4d36-8aa6-01e9ebb4632d
:DRILL_LAST_INTERVAL: 13.6826
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:02]
:END:

2 programming languages built around the concept of message passing:
sm[alltalk] and ea[rlang].

*** Item                                                            :drill:
SCHEDULED: <2022-07-30 sáb>
:PROPERTIES:
:ID:       dda55805-c5cf-4f9b-8c42-fed64a816853
:DRILL_LAST_INTERVAL: 11.2535
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:02]
:END:

Example of when not to use the actor model:

- when you need a seq[uential] order of things to happen.

*** Item                                                            :drill:
SCHEDULED: <2022-07-31 dom>
:PROPERTIES:
:ID:       7cd7ce70-c4f9-4089-b4b6-49de61d22db3
:DRILL_LAST_INTERVAL: 12.0725
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:05]
:END:

Orleans is a powerful tool to implement ac[tor] model pattern and it
is very useful in order developing APIs using Actor model in ASP.NET
Core.

** [[http://v2matveev.blogspot.com/2010/04/mailboxprocessors-erlang-style.html][MailboxProcessors: Erlang-style concurrency in F#]]

*** Item                                                            :drill:
SCHEDULED: <2022-07-31 dom>
:PROPERTIES:
:ID:       9019a660-7cd0-478a-939a-22df190bc074
:DRILL_LAST_INTERVAL: 11.8731
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2022-07-19 ter 14:02]
:END:

F#'s mailbox processor allows for searching messages of particular
type. This can be done w/ the functions ~S[can]~ and ~T[ryScan]~.

*** Item                                                            :drill:
:PROPERTIES:
:ID:       9c9f81c1-ca87-44ad-9eb2-3d3d15578d98
:END:
*** Item                                                            :drill:
:PROPERTIES:
:ID:       6011fac2-f2fb-46e9-92d8-f60177dbb776
:END:
*** Item                                                            :drill:
:PROPERTIES:
:ID:       a305c94c-d415-4a09-a56a-045830d0188b
:END:
